<?xml version="1.0" encoding="UTF-8"?>
<!--
%name:            autogen_general_doc.xml %
%version:         co1tss#91 %
%instance:        co1pctls_1 %
%derived_by:      nosterga %
%date_modified:   Mon Jul 19 10:49:41 2010 %
Copyright (c) Nokia. All rights reserved.
-->
<autogen>
  <revision release="Legal Notice" date="21-Jan-2009">
    <summary>
      The contents of this document are proprietary and confidential property of Nokia. This document is provided subject to confidentiality obligations of the applicable agreement(s).<br/><br/>
      This document is intended for use of Nokiaâ€™s customers and collaborators only for the purpose for which this document is submitted by Nokia. 
      No part of this document may be reproduced or made available to the public or to any third party in any form or means without the prior written permission of Nokia. 
      This document is to be used by properly trained professional personnel. <br/><br/>
      Any use of the contents in this document is limited strictly to the use(s) specifically authorized in the applicable agreement(s) under which the document is submitted. 
      The user of this document may voluntarily provide suggestions, comments or other feedback to Nokia in respect of the contents of this document ("Feedback"). 
      Such Feedback may be used in Nokia products and related specifications or other documentation. 
      Accordingly, if the user of this document gives Nokia Feedback on the contents of this document, Nokia may freely use, disclose, reproduce, license, distribute and otherwise commercialize the Feedback in any Nokia product, technology, service, specification or other documentation.<br/><br/>
      Nokia operates a policy of ongoing development. Nokia reserves the right to make changes and improvements to any of the products and/or services described in this document or withdraw this document at any time without prior notice.<br/><br/>
      The contents of this document are provided "as is". Except as required by applicable law, no warranties of any kind, either express or implied, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose, are made in relation to the accuracy, reliability or contents of this document. NOKIA SHALL NOT BE RESPONSIBLE IN ANY EVENT FOR ERRORS IN THIS DOCUMENT or for any loss of data or income or any special, incidental, consequential, indirect or direct damages howsoever caused, that might arise from the use of this document or any contents of this document.<br/><br/>
      This document and the product(s) it describes are protected by copyright according to the applicable laws.<br/><br/>
      Nokia is a registered trademark of Nokia Corporation. Other product and company names mentioned herein may be trademarks or trade names of their respective owners.<br/>
    </summary>
  </revision>
  <revision release="autogen 09w51" date="04-Dec-2009">
    <summary>
      Support for 64-bit macros, See: <see cref_topic="Using 64-bit macros"/>. PMD file format 6.00 is required along with resource property <see cref_property="PROPERTY_ALIGNMENT_64_BITS"/>. 
      Decoding requires FastTrace 3.4.
    </summary>
  </revision>
  <revision release="autogen 09w37" date="28-Aug-2009">
    <summary>
      Support for little endian (LE) in MERGE fields. PMD file format 5.01 must be used, and it is required that MERGE_BEGIN and fields all have the same endianess. Only exceptions are 1-bit versions of YES_NO, TRUE_FALSE, etc.<br/>
      Decoding requires FastTrace 3.2.
    </summary>
  </revision>

  <overview>
    <img src="pics/autogen_logo_web.gif"></img>
    <br/>
    This is a documentation system for autogen / message macros.
    Here, you should find latest documentation on message macros and examples of use.
  </overview>

  <groups>
    <group name="autogen user guide" type="Topics"/>
    <group name="General" type="Topics"/>
    <group name="Resources" type="Topics"/>
    <group name="Message items" type="Topics"/>
    <group name="FTD data" type="Topics"/>
    <group name="Traces" type="Topics"/>

    <group name="Property macros" type="Macros"/>
    <group name="Comment macros" type="Macros"/>
    <group name="Versioning macros" type="Macros"/>
    <group name="Feature flag macros" type="Macros"/>
    <group name="Resource macros" type="Macros"/>
    <group name="Message macros" type="Macros"/>
    <group name="Sub block macros" type="Macros"/>
    <group name="Sequence macros" type="Macros"/>
    <group name="Item macros" type="Macros"/>
    <group name="Constant macros" type="Macros"/>
    <group name="Trace macros" type="Macros"/>
    <group name="FTD macros" type="Macros"/>
    <group name="PPC macros" type="Macros"/>

    <group name="Versioning properties" type="Properties"/>
    <group name="Resource properties" type="Properties"/>
    <group name="Message properties" type="Properties"/>
    <group name="Sub block properties" type="Properties"/>
    <group name="Item properties" type="Properties"/>
    <group name="Trace properties" type="Properties"/>
    <group name="FTD properties" type="Properties"/>
    <group name="HTML properties" type="Properties"/>
    <group name="ISI header properties" type="Properties"/>
    <group name="PMD properties" type="Properties">
      <summary>
        This section describes properties affecting the PMD file.
      </summary>
    </group>
    <group name="General properties" type="Properties"/>
    <group name="Error codes" type="Errorcodes"/>
    <group name="Tutorial" type="Tutorial"/>
  </groups>
  <!-- 
=======================================================================================
 autogen user guide
======================================================================================= 
-->
  <topic name="Getting started" group="autogen user guide">
    <summary>
      When getting started with autogen, it is suggested to follow these steps:
      <ul>
        <li>Get an overview of what autogen is and how it is used. Coming here soon...</li>
        <li>
          Copy a template message macro file (see below) and integrate it in autogen.
          Use this as base for your own file.
        </li>
        <li>
          Read the relevant part of the <see cref_group="autogen user guide"/> topics.
        </li>
      </ul>
    </summary>
    <section name="Template macro files">
      <summary>
        <table border="0">
          <tr valign="top">
            <td>
              <img src="pics/doctype_h.gif"/>
            </td>
            <td>
              <a href="Examples/template_isi_m.h" class="cref link">template_isi_m.h</a><br/>
              This template can be used as base for defining an ISI resource (server) message macro file.
              See <see cref_topic="ISI private resources"/>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <img src="pics/doctype_h.gif"/>
            </td>
            <td>
              <a href="Examples/template_isi_shared_m.h" class="cref link">template_isi_shared_m.h</a><br/>
              This template can be used as base for defining a shared ISI resource message macro file, containing shared objects (such as constants and sub blocks).
              See <see cref_topic="Shared resources"/>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <img src="pics/doctype_h.gif"/>
            </td>
            <td>
              <a href="Examples/template_isi_priv_m.h" class="cref link">template_isi_priv_m.h</a><br/>
              This template can be used as base for defining a private ISI resource (server) message macro file. Private means that the used resource ID is PN_PRIVATE.
              See <see cref_topic="ISI private resources"/>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <img src="pics/doctype_h.gif"/>
            </td>
            <td>
              <a href="Examples/template_isi_prefix_m.h" class="cref link">template_isi_prefix_m.h</a><br/>
              This template can be used as base for defining a macro file foe an extended ISI resource on <b>PN_PREFIX</b>.
              See <see cref_topic="ISI prefix resources"/>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <img src="pics/doctype_h.gif"/>
            </td>
            <td>
              <a href="Examples/template_mon.ti" class="cref link">template_mon.ti</a><br/>
              This template can be used as base for defining a .ti file with MCU trace definitions, optimised for PMD decoding.
              See <see cref_topic="MCU traces"/>
            </td>
          </tr>
          <tr valign="top">
            <td>
              <img src="pics/doctype_h.gif"/>
            </td>
            <td>
              <a href="Examples/template_invariant_trace_m.h" class="cref link">template_invariant_trace_m.h</a><br/>
              This template can be used as base for defining a message macro file with invariant trace definitions.
              See <see cref_topic="Invariant traces"/>
            </td>
          </tr>
        </table>
      </summary>
    </section>
  </topic>
  <topic name="autogen environments" group="autogen user guide">
    <summary>
      In this section, the autogen environments are described.
    </summary>
    <section name="Product environment">
      <summary>
        Product environment is the <b>wp_sw</b> build environment. In this environment, only PMD files can be generated.
        <br/><br/>
        The product environment must contain <b>autogen_conf.h</b> in which build-specific autogen flags can be set.
        <br/>
        Please see <b>example_autogen_conf.h</b> for a list of flags and default values.
        <br/><br/>
        Most message macro files are configured in by autogen through compile flags.
        <br/>
        The following files include message definition files:
        <ul>
          <li>
            <b>autogen_coresw.h</b> (Common message and various core interfaces)
          </li>
          <li>
            <b>autogen_coresw2.h</b> (various core interfaces)
          </li>
          <li>
            <b>autogen_coresw3.h</b> (various core interfaces)
          </li>
          <li>
            <b>autogen_coresw4.h</b> (various core interfaces)
          </li>
          <li>
            <b>autogen_coresw_cl.h</b> (Communication Manager, PhoNet and Media Module interfaces)
          </li>
          <li>
            <b>autogen_coresw_mon.h</b> (Monitor server interface)
          </li>
          <li>
            <b>autogen_dsp.h</b> (DSP interfaces)
          </li>
          <li>
            <b>autogen_iam.h</b> (MAUI interfaces)
          </li>
          <li>
            <b>autogen_iam2.h</b> (MAUI interfaces)
          </li>
          <li>
            <b>autogen_iam3.h</b> (MAUI interfaces)
          </li>
          <li>
            <b>autogen_protocols.h</b> (general protocol interfaces)
          </li>
          <li>
            <b>autogen_protocols2.h</b> (general protocol interfaces)
          </li>
          <li>
            <b>autogen_protocols3.h</b> (general protocol interfaces)
          </li>
          <li>
            <b>autogen_protocols_gsm.h</b> (GSM specific protocol interfaces)
          </li>
          <li>
            <b>autogen_protocols_wcdma.h</b> (WCDMA specific protocol interfaces)
          </li>
          <li>
            <b>autogen_protocols_eutran.h</b> (EUTRAN specific protocol interfaces)
          </li>
          <li>
            <b>autogen_ostrich.h</b> (trace box interface)
          </li>
        </ul>
        <br/>
        If other macro files should be included in the build, these must be included in the product configuration file <b>autogen_server_conf.h</b>.
      </summary>
    </section>
    <section name="Product environment device">
      <summary>
        Product environment device is the <b>Device</b> build environment, e.g. <b>EUTRAN</b>. In this environment, only PMD files can be generated.
        <br/><br/>
        The product environment device must contain <b>autogen_conf.h</b> in which build-specific autogen flags can be set.
        <br/>
        Please see <b>example_autogen_conf.h</b> for a list of flags and default values.
        <br/><br/>
        One PMD file is generated for each processor. These Device PMD files can be embedded into a product (MCU) PMD file.
        <br/>
        To indicate to autogen for which processor a PMD file is to be generated 9 flags are available. For all practical purposes only one flag should be ON for each PMD generation.
        <br/>
        The following processor specific files <b>which are not owned by autogen</b> include message definition files:
        <ul>
          <li>
            <b>processor1_files.h</b> (AUTOGEN_PROCESSOR_1 ON)
          </li>
          <li>
            <b>processor2_files.h</b> (AUTOGEN_PROCESSOR_2 ON)
          </li>
          <li>
            <b>processor3_files.h</b> (AUTOGEN_PROCESSOR_3 ON)
          </li>
          <li>
            <b>processor4_files.h</b> (AUTOGEN_PROCESSOR_4 ON)
          </li>
          <li>
            <b>processor5_files.h</b> (AUTOGEN_PROCESSOR_5 ON)
          </li>
          <li>
            <b>processor6_files.h</b> (AUTOGEN_PROCESSOR_6 ON)
          </li>
          <li>
            <b>processor7_files.h</b> (AUTOGEN_PROCESSOR_7 ON)
          </li>
          <li>
            <b>processor8_files.h</b> (AUTOGEN_PROCESSOR_8 ON)
          </li>
          <li>
            <b>processor9_files.h</b> (AUTOGEN_PROCESSOR_9 ON)
          </li>
        </ul>
        <br/>
        If other macro files should be included in the build, these must be included in the product configuration file <b>autogen_server_conf.h</b>.
        <br/>
      </summary>
    </section>
    <section name="Local environment">
      <summary>
        When running autogen in local environment, no message definition files are automatically included.
        <br/><br/>
        The file <b>autogen_local_server_conf.h</b> should include all the *_m.h files needed for the autogen execution.
        Create the file locally in your autogen directory.
        Besides, you must create the file <b>autogen_local_conf.h</b>. Refer to the file <b>example_autogen_conf.h for possible flags</b>. Normally, the file should just be empty.
        <br/><br/>
        Header files <b>pn_const.h</b> and <b>global.h</b> should be copied to your autogen directory, 
        if you are not using autogen as part of a build environment, such as <b>wp_sw</b>.
      </summary>
    </section>
  </topic>
  <topic name="Generating outputs from autogen" group="autogen user guide">
    <summary>
      This section describes which outputs autogen supports, and how they are generated.
    </summary>
  </topic>
  <subtopic name="PMD files" topic="Generating outputs from autogen">
    <summary>
      This section describes the different PMD file types and how they are generated with autogen.
    </summary>
    <section name="RD PMD files">
      <summary>
        RD PMD file is the PMD file generated in product SW builds, such as <b>wp_sw</b>.
        <br/><br/>
        The file is highly Nokia confidential, as it contains vital information about ISA architecture and all ISA interfaces.
        <br/><br/>
        Main use for RD PMD files is to test/debug RD SW.
        <br/><br/>
        <b>Product environment (wp_sw build, root):</b>
        <br/><br/>
        PMD file can be generated from the root of the <b>wp_sw</b> project this way:
        <code filename="make_product_pmd_wp_sw.txt"/>
        The following two PMD files are generated in <b>coresw/coretools/autogen/pmd</b>:
        <b>(identifier).pmd</b>, <b>(identifier).P.pmd</b>, <b>(identifier).R.pmd</b> and <b>product.pmd</b>.
        The files <b>(identifier).pmd</b> and <b>product.pmd</b> are identical, and only <b>(identifier).pmd</b> should be stored in Lotus Notes for releases.
        <br/><br/>
        Cleaning autogen can be done this way:
        <code filename="make_product_pmd_wp_sw_clean.txt"/>
        <i>
          Note that cleaning autogen tools also erases the file <b>mon_trace_group_ids.h</b>,
          which defines all MCU trace groups
        </i>.
        The file can be regenerated this way:
        <code filename="make_mon_trace_group_ids_wp_sw.txt"/>
        <br/>
        <b>Product environment (wp_sw build, autogen directory):</b>
        <br/><br/>
        PMD file can be generated from the autogen directory of <b>wp_sw</b>.
        autogen directory is located in <b>/coresw/coretools/autogen</b>.
        <code filename="make_product_pmd.txt"/>
        <i>
          Note that this PMD file will not contain symbol information (from <b>.out</b> file).
          Else, the PMD file is identical to the one generated from the root of <b>wp_sw</b>
        </i>
        <br/><br/>
      </summary>
    </section>
    <section name="Restricted PMD files">
      <summary>
        Restricted PMD files are highly reduced PMD files to be used with <b>Optra</b> tool, and can be provided for close and trusted 3rd parties to Nokia.
        <br/><br/>
        Contents of restricted PMD files:
        <br/>
        <table border="0">
          <tr valign="top">
            <td nowrap="">
              <b>Element</b>
            </td>
            <td>
              <b>Description</b>
            </td>
          </tr>
          <tr valign="top">
            <td nowrap="">
              <see cref_topic="Invariant traces"/>
            </td>
            <td>Full support</td>
          </tr>
          <tr valign="top">
            <td nowrap="">RD traces</td>
            <td>
              Only information used for trace activation. No decode support
            </td>
          </tr>
          <tr valign="top">
            <td nowrap="">ISI messages</td>
            <td>
              Only messages marked as restricted or public (using properties <b>PROPERTY_PMD_RESTRICTED</b> or <b>PROPERTY_PMD_PUBLIC</b>) are included
            </td>
          </tr>
          <tr valign="top">
            <td nowrap="">
              <see cref_group="FTD data" />
            </td>
            <td>
              Only FTDs defined to support infra-vendors (using property <see cref_property="PROPERTY_FTD_SUPPORTED_MODES" />) are included
            </td>
          </tr>
        </table>
        <br/>
        Restricted PMD files are from autogen 06_w47 automatically generated with the product PMD files. 
        PMD file is generated as <b>(identifier).R.pmd</b> in <b>coresw/coretools/autogen/pmd</b>.
      </summary>
    </section>
    <section name="Public PMD files">
      <summary>
        Public PMD files are highly reduced PMD files to be used with <b>Optra</b> tool, and can be provided for distant 3rd parties to Nokia.
        <br/><br/>
        Contents of public PMD files:
        <br/>
        <table border="0">
          <tr valign="top">
            <td nowrap="">
              <b>Element</b>
            </td>
            <td>
              <b>Description</b>
            </td>
          </tr>
          <tr valign="top">
            <td nowrap="">
              <see cref_topic="Invariant traces"/>
            </td>
            <td>Full support</td>
          </tr>
          <tr valign="top">
            <td nowrap="">RD traces</td>
            <td>
              No support
            </td>
          </tr>
          <tr valign="top">
            <td nowrap="">ISI messages</td>
            <td>
              Only messages marked as public (using property <b>PROPERTY_PMD_PUBLIC</b>) are included
            </td>
          </tr>
          <tr valign="top">
            <td nowrap="">
              <see cref_group="FTD data" />
            </td>
            <td>
              Only FTDs defined to support operators (using property <see cref_property="PROPERTY_FTD_SUPPORTED_MODES" />) are included
            </td>
          </tr>
        </table>
        <br/>
        Public PMD file can be generated from the autogen directory this way:
        <code filename="make_public_pmd.txt"/>
        PMD file is generated as <b>(identifier).pmd</b> in <b>coresw/coretools/autogen/pmd_public</b>.
        Along with the PMD file, some text files describing the PMD file content are generated in the same directory.
      </summary>
    </section>
    <section name="Local PMD files">
      <summary>
        Local PMD files are generated in autogens local environment. 
        Local PMD files oonly include the resources / trace definitions defined in the file <b>autogen_local_server_conf.h</b>.
        <br/><br/>
        The PMD file can for example be used to verify interface changes through PMD message sending / decoding in FastTrace.
        <br/><br/>
        To generate the file, execute the make file from autogen directory.
        <code filename="make_local_pmd.txt"/>
        Output is generated to <b>coresw/coretools/autogen/pmd</b> directory.
      </summary>
    </section>
    <section name="Compatibility between PMD files">
      <summary>
        PMD files are read by the Tracing SDK library such that it can decode trace messages. For this reason the PMD file
        format is laid out in a very specific format agreed between autogen and Tracing SDK.<br/>
        <br/>
        Sometimes new functionality causes changes to the PMD file format and the PMD file format
        version number is updated. These changes can cause incompatibility between PMD file versions which may cause problems
        for Tracing SDK to correctly append PMD files together.<br/>
        <br/>
        To avoid such problems checks has been implemented in autogen and Tracing SDK to detect such cases and reject
        incompatible PMD files.<br/>
        <br/>
        Please see this page for further information: <a href="http://rdsuite/Default.aspx?wiki_2_page=pmd_guides" class="cref link">PMD File Format Compatibility</a>
      </summary>
    </section>
  </subtopic>
  <subtopic name="Debug information (PMD)" topic="Generating outputs from autogen">
    <summary>
      Autogen supports adding debug information from the .out file to a RD PMD file. This can be useful when e.g. 
      decoding Mulder dumps in FastTrace. The debugging information 
      is added to the PMD file when autogen is running in product environment and consist of two parts. 
      <ul>
        <li>Source file and function debugging information.</li>
        <li>Line number debugging information.</li>        
      </ul>
      The source file and function debugging information is always included in the PMD file.<br/>
      But line number information must be enabled using a flag to be included in the PMD file. This is due to two limitations:<br/>
      <ul>
        <li>This is due to the size of the PMD file which becomes a lot bigger (around 4 times bigger)when line numbers are included.</li>
        <li>Currently it takes a long time loading the PMD file in FastTrace. (10-15 minutes have been seen)</li>
      </ul> 
      It is therefor only recommmended to add line number information when really needed. <br/>
      <br/>
      The following steps describes how to enable line number information being added to the PMD file.
      <ul>
        <li>The flag AUTOGEN_PMD_LINE_NUMBERS must be set in autogen_conf.h. This will enable autogen to generate 
            line numbers in the PMD file.</li>
        <li>The phone build must be compiled with debug information.</li>
        <li>Clean the autogen build and re-compile autogen as described in <see cref_subtopic="PMD files"/></li>
        <li>A PMD file with line number information can be found in the autogen/PMD directory.</li>
      </ul>
      <br/>
      <b>Shared libraries</b><br/>
      Autogen also supports function and line number debugging information from shared libraries (DLL libraries).
      The steps are the same as for adding debug information from the main .out file except that the DLL .out files
      (one or more) must be added as a autogen command line parameters. Autogen will then know where to read the 
      relevant .out file.<br/>
      <br/>
      The following command line parameter specifies the location of a .out file (main or DLL):<p/>
      <ul>
      	<li>-out(filepath of DLL)</li>
      </ul>
      E.g. -out/mydir/my.dll.out<br/>
      <br/>
      This command line parameter must be added after autogen executable name in the relevant makefile in the autogen directory.
      In the makefile look for the 'define RunAutogen' sentence.<br/>
      Add such a command line parameter for each DLL that autogen must extract debugging information from.<br/>
      <br/>
      Note that the <b>-out$(OUT_FILE)</b> should not be touched as this is the one that includes the main .out file.
    </summary>
  </subtopic>
  <subtopic name="ISI message descriptions (HTML)" topic="Generating outputs from autogen">
    <summary>
      HTML documentation of the interfaces and trace definitions.
      <br/><br/>
      Generating HTML files:
      <code filename="make_local_html.txt"/>
      Output is generated to a <b>GIF_SPECS</b> or <b>Core_Specs</b> structure below <b>coresw/coretools/autogen/html</b> directory.
      <br/>
      Location can be found in message definition file from the resource property <see cref_property="PROPERTY_HTML_DIRECTORY_PATH" />, eg.
      <see cref_macro="PROPERTY_STRING" />(<see cref_property="PROPERTY_HTML_DIRECTORY_PATH" />, "GIF_SPECS/CoreSW")
      <br/><br/>
      To generate output for 3rd party vendors please see <see cref_property="PROPERTY_NOKIA_3RD_PARTY_VENDOR_OUTPUT" />
      <br/><br/>
    </summary>
  </subtopic>
  <subtopic name="ISI header files" topic="Generating outputs from autogen">
    <summary>
      C Header files used as part of the source code for the software components.
      <br/><br/>
      Generating ISI header files:
      <code filename="make_local_isihdr.txt"/>
      Output is generated to <b>coresw/coretools/autogen/isihdr</b> directory.
      <br/><br/>
      To generate output for 3rd party vendors please see <see cref_property="PROPERTY_NOKIA_3RD_PARTY_VENDOR_OUTPUT" />
      <br/><br/>
    </summary>
  </subtopic>
  <subtopic name="TSS Server API source files" topic="Generating outputs from autogen">
    <summary>
      C++ classes for encoding/decoding messages to the server. Used as part of the source code in the TSS API.
      <br/><br/>
      Generating TSS Server API source files:
      <code filename="make_local_tsa.txt"/>
      Output is generated to autogen/tsa directory.
      <br/><br/>
    </summary>
  </subtopic>
  <subtopic name="XML Interface descriptions" topic="Generating outputs from autogen">
    <summary>
      XML representation of the interfaces.
      To be used as base for generating custom outputs and extraction of information across interfaces
      <br/><br/>
      Generating XML output files:
      <code filename="make_local_xml.txt"/>
      Output is generated to <b>coresw/coretools/autogen/xml</b> directory.<br/>
      <br/>
      The XML output contains the same information as the source macro file and can be used by third party as input to
      to generation of custom output which autogen does not support out of the box.<br/>
      The output generally consist of a XML file containing the resource definition and a XML file containing the 
      the symbols.<br/>
      <br/>
      The following will give a short introduction to the format, but for a full syntax please check the XML schema,
      which describes the full syntax. The schema can be found in the autogen source code directory 
      and is named <b>autogen_xml.xsd</b>.<br/>
      <br/>
      The XML file with the resource definition contains one resource definition which is enclosed between the 
      following two tags: AutogenXml. Between these two tags the following resource types are supported:<br/>
      <ul>
        <li>ResourceShared</li>
        <li>ResourceIsi</li>
        <li>ResourceIsiExtension</li>
        <li>ResourceIsiCommon</li>
        <li>ResourceIsiCommonExtension</li>
        <li>ResourceIsiPrivate</li>
        <li>ResourceIsiPrefix</li>
        <li>ResourcePhonet</li>
        <li>ResourcePhonetExtended</li>
        <li>ResourceMediaModule</li>
        <li>ResourceMediaModuleExtension</li>
        <li>ResourceGenericProtocol</li>
        <li>ResourceGenericProtocolExtension</li>
        <li>ResourceInvariantTraces</li>
      </ul>
      <br/>
      The each resource is subdivided into a number of sections each containing one type of definitions:<br/>
      <table border="0">
        <tr><td>Description</td>
            <td>This contains the server description that is located in the comment macros related to the <see cref_macro="RES_BEGIN"/> macro.</td></tr>
        <tr><td>ProjectInfo</td>
            <td>This contains the project information that comes from the PROPERTY_PROJECT_XXX properties related to the
                <see cref_macro="RES_BEGIN"/>.</td></tr>
        <tr><td>DescriptionNotes</td>
            <td>This section contains the information collected by the comments associated with <see cref_macro="NOTE"/> macros.</td></tr>
        <tr><td>VersionHistory</td>
            <td>This section contains the version history of the server that comes from the PROPERTY_CHANGE_XXX properties 
                associated with the <see cref_macro="ISI_VERSION_HISTORY"/>.</td></tr>
        <tr><td>SharedFiles</td>
            <td>This section lists all the shared files included into this resource definition. Please see 
                <see cref_macro="INCLUDE_SHARED_FILE"/>.</td></tr>
        <tr><td>Constants</td>
            <td>This section lists all the defined constants. Please see <see cref_macro="CONSTANT"/>.</td></tr>
        <tr><td>Tables</td>
            <td>This section lists all tables like <see cref_macro="CONST_TBL_BEGIN"/>, <see cref_macro="BIT_TBL_BEGIN"/>, 
                <see cref_macro="DER_CONST_TBL_BEGIN"/>, <see cref_macro="DER_BIT_TBL_BEGIN"/> and <see cref_macro="FTD_TBL_BEGIN"/> 
                </td></tr>
        <tr><td>Structures</td>
            <td>This section lists structures like <see cref_macro="SEQ_BEGIN"/>.</td></tr>
        <tr><td>Subblocks</td>
            <td>This section contains subblock definitions. See <see cref_macro="SB_BEGIN"/>.</td></tr>
        <tr><td>SubblockTemplates</td>
            <td>This section contains subblock template definitions.</td></tr>
        <tr><td>Messages</td>
            <td>This section contains all message definitions. Please see <see cref_macro="MSG_BEGIN"/> and 
                <see cref_macro="SUB_MSG_BEGIN"/>.</td></tr>
        <tr><td>TraceGroups</td>
            <td>This section contains all tracegroup and trace definitions. See <see cref_macro="TRACE_GROUP_BEGIN"/>.</td></tr>
      </table>
      <br/>
      The following example is the XML output generated from templace file <see cref_example="Template file for ISI resources"/>.<br/>
      <code filename="tut_xxxx_isi.xml"/>
      <br/><br/>
    </summary>
  </subtopic>
  <!-- 
=======================================================================================
 General
======================================================================================= 
-->
  <!-- 
=======================================================================================
 Message macro update guide
======================================================================================= 
-->
  <topic name="Message macro update guide" group="General">
    <summary>
      This section describes how to update message definition files for autogen to the current set of macros.
      autogen is being continuously developed to support new features and remove deficiencies.
      These updates sometimes require changes to the set of macros supported.
      While autogen maintains a high degree of backward compatibility, older macros typically have less error checking,
      worse error messages and are more diverse than the newer counterparts.
      If nontrivial changes are being made to a message definition file,
      it is suggested that it's updated to use the new macros at the same time.
      <br/><br/>
      In addition, this section can be used as a reference for old macros,
      in case you need to understand a message definition file using the old macros.
      <br/><br/>
      If you are using MS Visual Studio for developing message macro files, you should install the
      message macro color highliting. Simpl click the link below, install, and restart your
      MS Visual Studio. Now, all new macros will be shown in blue.
      <table border="0">
        <tr valign="top">
          <td>
            <img src="pics/doctype_exe.gif"/>
          </td>
          <td>
            <a href="docs/autogen_usertype.exe" class="cref link">autogen_usertype.exe</a>
          </td>
        </tr>
      </table>
    </summary>
    <section name="Comment macro changes">
      <summary>
        A number of <b>XXX_COMMENT</b> macros have been replaced by a generic <see cref_macro="COMMENT"/> macro.
        <br/>
        In addition, some of the comment types previously used have been changed to properties using the
        <see cref_macro="COMMENT_PROPERTY"/>, <see cref_macro="PROPERTY"/> or <b>PROPERTY_XXX</b> macros instead.
        The table below lists the obsolete comment types and their current replacement.
        Please note that the new comment and property macros must be placed before the object that they affect,
        regardless of the type of the object.
        <table valign="top">
          <tr>
            <th>Comment type</th>
            <th>New macro/property</th>
          </tr>
          <tr>
            <td>
              <b>AUTOGEN_COMMENT_ANCHOR</b>
            </td>
            <td>
              <see cref_macro="BLOCK_REF"/>(BE, ..., BLOCK_PMD_ANCHOR, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>AUTOGEN_COMMENT_FIELD</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(<b>COMMENT_TEXT</b>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ALL_OUTPUTS</b>
            </td>
            <td>
              <see cref_macro="COMMENT_PROPERTY"/>(<b>COMMENT_PROPERTY_ALL_OUTPUTS</b>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ANCHOR</b>
            </td>
            <td>
              <see cref_macro="BLOCK_REF"/>(BE, ..., BLOCK_PMD_ANCHOR, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_CHANGE_DATE</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_CHANGE_DATE"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_CHANGE_PERSON</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_CHANGE_PERSON"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_CHANGE_REASON</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_CHANGE_REASON"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_CHANGE_REFERENCE</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_CHANGE_REFERENCE"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_CHANGE_STATUS</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_CHANGE_STATUS"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_CONFIDENTIALITY</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_PROJECT_CONFIDENTIALITY"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_CONTINUUS_INSTANCE_NAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_CONTINUUS_INSTANCE_NAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_CONTINUUS_PROJECT_NAME</b>
            </td>
            <td>This comment type is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_DEFINITION_NAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_DEFINITION_NAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_DEVICE_ID</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_VALUE"/>(<see cref_property="PROPERTY_PMD_PHONET_DEVICE_ID"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_DISABLE_ALIGNMENT_CHECK</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_ALIGNMENT_CHECK_DISABLE"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_HTML_CONTINUUS_PROJECT_NAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_HTML_CONTINUUS_PROJECT_NAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_HTML_DISABLE</b>
            </td>
            <td>
              <see cref_macro="COMMENT_PROPERTY"/>(<b>COMMENT_PROPERTY_HTML_DISABLE</b>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_HTML_DOCUMENT_NUMBER</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_HTML_DOCUMENT_NUMBER"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_HTML_FILENAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_HTML_FILENAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_HTML_ONLY</b>
            </td>
            <td>
              <see cref_macro="COMMENT_PROPERTY"/>(<b>COMMENT_PROPERTY_HTML_ONLY</b>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_HTML_TITLE</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_HTML_TITLE"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_INCLUDE_HTML_INTRODUCTION</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_HTML_INCLUDE_INTRODUCTION"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_INCLUDE_PN_TRACE_OBJECTS</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<b>PROPERTY_INCLUDE_PN_TRACE_OBJECTS</b>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISI_VERSION_NO_LONGER_SUPPORTED</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_VERSION_NO_LONGER_SUPPORTED"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISI_VERSION_NOT_YET_SUPPORTED</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_VERSION_NOT_YET_SUPPORTED"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_ALIAS_NAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_ALIAS_NAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_DEFINITION_NAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_DEFINITION_NAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_DISABLE</b>
            </td>
            <td>
              <see cref_macro="COMMENT_PROPERTY"/>(<b>COMMENT_ISIHDR_DISABLE</b>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_DONT_GENERATE</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_ISIHDR_DONT_GENERATE"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_FILENAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_FILENAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_FILENAME_16</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_FILENAME_16"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_GENERATE_AS_BITFIELD</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_ISIHDR_GENERATE_AS_BITFIELD"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_GENERATE_AS_BOOL</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_ISIHDR_GENERATE_AS_BOOL"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_GENERATE_BITFIELDS</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_ISIHDR_GENERATE_BITFIELDS"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_GENERATE_BOOLS</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_ISIHDR_GENERATE_BOOLS"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_ONLY</b>
            </td>
            <td>
              <see cref_macro="COMMENT_PROPERTY"/>(<b>COMMENT_PROPERTY_ISIHDR_ONLY</b>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_SPLIT_DWORD_SIGNED</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_SPLIT_DWORD_SIGNED"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_SPLIT_DWORD_UNSIGNED</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_SPLIT_DWORD_UNSIGNED"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_SPLIT_WORD_SIGNED</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_SPLIT_WORD_SIGNED"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_SPLIT_WORD_UNSIGNED</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_SPLIT_WORD_UNSIGNED"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_STRUCT_LENGTH_NAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_STRUCT_LENGTH_NAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_STRUCT_NAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_STRUCT_NAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_TITLE</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_TITLE"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_ISIHDR_VARNAME_16</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_VARNAME_16"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_MEDIA_CTRL_SPECIFIC_MSG</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<b>PROPERTY_MSG_IS_MEDIA_CTRL_SPECIFIC</b>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_OBJECT_ID</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_VALUE"/>(<see cref_property="PROPERTY_PMD_PHONET_OBJECT_ID"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_OWNER_NAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_PROJECT_OWNER_NAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_PCMS_HTML_ITEM</b>
            </td>
            <td>This comment type is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_PCMS_HTML_PART</b>
            </td>
            <td>This comment type is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_PCMS_ISIHDR_ITEM</b>
            </td>
            <td>This comment type is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_PCMS_ISIHDR_ITEM_16</b>
            </td>
            <td>This comment type is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_PCMS_ISIHDR_PART</b>
            </td>
            <td>This comment type is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_PCMS_WORKSET</b>
            </td>
            <td>This comment type is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_PROJECT_NAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_PROJECT_NAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_RAW_DATA</b>
            </td>
            <td>This comment type is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_SB_LENGTH_RELATES_TO_DATA_PART_ONLY</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_SB_LENGTH_RELATES_TO_DATA_PART_ONLY"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_SITE_NAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_PROJECT_SITE_NAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_STATIC_DATA</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_FTD_IS_STATIC_DATA"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_STRUCT_LENGTH__NAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_STRUCT_LENGTH_NAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_STRUCT_NAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_STRUCT_NAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_SUBMSG_NAMES_ARE_UNIQUE</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_SUBMSG_NAMES_ARE_UNIQUE"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_SUPPORT_BITFIELDS_IN_ISIHDR</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_ISIHDR_GENERATE_BITFIELDS"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_SUPPORT_BOOLS_IN_ISIHDR</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_ISIHDR_GENERATE_BOOLS"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>COMMENT_SUPPORT_DYN_STRUCTS_IN_ISIHDR</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_ISIHDR_GENERATE_ALL_STRUCTURE_ELEMENTS"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>FIELD_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(<b>COMMENT_TEXT</b>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>GENERAL_COMMENT</b>
            </td>
            <td>Ignored for all purposes except L1NUTS</td>
          </tr>
        </table>
      </summary>
    </section>
    <section name="Property name changes">
      <summary>
        A number of properties have changed names since they were first introduces.
        The following table maps old property names to their new counterparts.
        <table valign="top">
          <tr>
            <th>Old name</th>
            <th>New name</th>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_CONFIDENTIALITY</b>
            </td>
            <td>
              <see cref_property="PROPERTY_PROJECT_CONFIDENTIALITY"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_CONTINUUS_INSTANCE_NAME</b>
            </td>
            <td>
              <see cref_property="PROPERTY_ISIHDR_CONTINUUS_INSTANCE_NAME"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_CONTINUUS_PROJECT_NAME</b>
            </td>
            <td>This property is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_FTD_IS_COMMAND</b>
            </td>
            <td>This property is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_HTML_PCMS_ITEM</b>
            </td>
            <td>This property is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_HTML_PCMS_PART</b>
            </td>
            <td>This property is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_ISIHDR_PCMS_ITEM</b>
            </td>
            <td>This property is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_ISIHDR_PCMS_ITEM_16</b>
            </td>
            <td>This property is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_ISIHDR_PCMS_PART</b>
            </td>
            <td>This property is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_ISIHDR_PCMS_WORKSET</b>
            </td>
            <td>This property is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_ITEM_PMD_ANCHOR</b>
            </td>
            <td>
              <see cref_macro="BLOCK_REF"/>(BE, ..., BLOCK_PMD_ANCHOR, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_OWNER_NAME</b>
            </td>
            <td>
              <see cref_property="PROPERTY_PROJECT_OWNER_NAME"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_PCMS_WORKSET</b>
            </td>
            <td>This property is obsolete and is ignored.</td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_PHONET_DEVICE_ID</b>
            </td>
            <td>
              <see cref_property="PROPERTY_PMD_PHONET_DEVICE_ID"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_PHONET_HEADER_LAYOUT</b>
            </td>
            <td>
              <see cref_property="PROPERTY_ISIHDR_PHONET_HEADER_LAYOUT"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_PHONET_OBJECT_ID</b>
            </td>
            <td>
              <see cref_property="PROPERTY_PMD_PHONET_OBJECT_ID"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_PMD_ANCHOR</b>
            </td>
            <td>
              <see cref_macro="BLOCK_REF"/>(BE, ..., BLOCK_PMD_ANCHOR, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>PROPERTY_SITE_NAME</b>
            </td>
            <td>
              <see cref_property="PROPERTY_PROJECT_SITE_NAME"/>
            </td>
          </tr>
        </table>
      </summary>
    </section>
    <section name="Environment variable changes">
      <summary>
        Environment variables are now set using the <b>PROPERTY_PMD_ENVIRONMENT_VARIABLE</b> property.
        This is an indexed property using the specific environment variable as an index.
        It can be set using the indexed property macros <see cref_macro="PROPERTY_STRING_INDEX"/> and <see cref_macro="PROPERTY_VALUE_INDEX"/>.
        <br/><br/>
        The following table maps the old environment variable names to their new counterparts.
        <table valign="top">
          <tr>
            <th>Old name</th>
            <th>New name</th>
          </tr>
          <tr>
            <td>
              <b>ENV_CONST_MCU_TRACE_BITMAP_ID</b>
            </td>
            <td>
              <b>PMD_ENVIRONMENT_VAR_ID_MCU_TRACE_BITMAP_ID</b>
            </td>
          </tr>
          <tr>
            <td>
              <b>ENV_VAR_MCU_TRACE_BITMAP_ID</b>
            </td>
            <td>
              <b>PMD_ENVIRONMENT_VAR_ID_MCU_TRACE_BITMAP_ID</b>
            </td>
          </tr>
          <tr>
            <td>
              <b>ENV_CONST_MCU_TRACE_BITMAP_LENGTH</b>
            </td>
            <td>
              <b>PMD_ENVIRONMENT_VAR_ID_MCU_TRACE_BITMAP_LENGTH</b>
            </td>
          </tr>
          <tr>
            <td>
              <b>ENV_VAR_MCU_TRACE_BITMAP_LENGTH</b>
            </td>
            <td>
              <b>PMD_ENVIRONMENT_VAR_ID_MCU_TRACE_BITMAP_LENGTH</b>
            </td>
          </tr>
          <tr>
            <td>
              <b>ENV_VAR_OS_TICKS_INTERVAL</b>
            </td>
            <td>
              <b>PMD_ENVIRONMENT_VAR_ID_OS_TIMER_INTERVAL</b>
            </td>
          </tr>
          <tr>
            <td>
              <b>ENV_VAR_MCU_SW_VERSION</b>
            </td>
            <td>
              <b>PMD_ENVIRONMENT_VAR_ID_MCU_SW_VERSION</b>
            </td>
          </tr>
          <tr>
            <td>
              <b>ENV_VAR_CDSP_SW_VERSION</b>
            </td>
            <td>
              <b>PMD_ENVIRONMENT_VAR_ID_CDSP_SW_VERSION</b>
            </td>
          </tr>
          <tr>
            <td>
              <b>ENV_VAR_ADSP_SW_VERSION</b>
            </td>
            <td>
              <b>PMD_ENVIRONMENT_VAR_ID_ADSP_SW_VERSION</b>
            </td>
          </tr>
          <tr>
            <td>
              <b>ENV_VAR_PMD_FILE_TYPE</b>
            </td>
            <td>
              <b>PMD_ENVIRONMENT_VAR_ID_PMD_FILE_TYPE</b>
            </td>
          </tr>
        </table>
      </summary>
    </section>
    <section name="Old macro reference">
      <summary>
        Convertion table for old message macros.
        <table valign="top">
          <tr>
            <th>Macro</th>
            <th>New macro/property</th>
          </tr>
          <tr>
            <td>
              <b>BCD_REF_ENTRY</b>
            </td>
            <td>
              <see cref_property="PROPERTY_STRING_BCD_MAP"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>BCD_TBL_BEGIN</b>
            </td>
            <td>
              <see cref_property="PROPERTY_STRING_BCD_MAP"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>BCD_TBL_END</b>
            </td>
            <td>
              <see cref_property="PROPERTY_STRING_BCD_MAP"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>BCD_TBL_ENTRY</b>
            </td>
            <td>
              <see cref_property="PROPERTY_STRING_BCD_MAP"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>BIT_REF</b>
            </td>
            <td>
              <see cref_macro="VALUE_CONST"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>BIT_TBL_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)<br/><see cref_macro="BIT_TBL_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>BIT_TBL_COMMENT_LINK</b>
            </td>
            <td>
              <see cref_macro="COMMENT_LINK"/>(LINK_TABLE, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>BIT_TBL_ENTRY_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>CASE</b>
            </td>
            <td>
              Replaced by <see cref_macro="CASE_BEGIN"/> and <see cref_macro="CASE_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>CASE_DEFAULT</b>
            </td>
            <td>
              Replaced by <see cref_macro="DEFAULT_BEGIN"/> and <see cref_macro="DEFAULT_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>CASE_VER</b>
            </td>
            <td>
              Replaced by <see cref_macro="CASE_BEGIN"/> and <see cref_macro="CASE_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>CONST_REF</b>
            </td>
            <td>
              <see cref_macro="VALUE_CONST"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>CONST_TBL_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)<br/><see cref_macro="CONST_TBL_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>CONST_TBL_COMMENT_LINK</b>
            </td>
            <td>
              <see cref_macro="COMMENT_LINK"/>(LINK_TABLE, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>CONST_TBL_ENTRY_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>CONST_TBL_ENTRY_COMMENT_LINK</b>
            </td>
            <td>
              <see cref_macro="COMMENT_LINK"/>(link_type, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>CONSTANT_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)<br/><see cref_macro="CONSTANT"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>CONSTANT_COMMENT_LINK</b>
            </td>
            <td>
              <see cref_macro="COMMENT_LINK"/>(LINK_CONSTANT, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_BIT_TBL_BEGIN</b>
            </td>
            <td>
              <see cref_macro="BIT_TBL_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_BIT_TBL_END</b>
            </td>
            <td>
              <see cref_macro="BIT_TBL_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_CHOICE_REF_BEGIN</b>
            </td>
            <td>
              <see cref_macro="CHOICE_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_CHOICE_REF_END</b>
            </td>
            <td>
              <see cref_macro="CHOICE_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_CONST_TBL_BEGIN</b>
            </td>
            <td>
              <see cref_macro="CONST_TBL_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_CONST_TBL_END</b>
            </td>
            <td>
              <see cref_macro="CONST_TBL_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_MERGE_BEGIN</b>
            </td>
            <td>
              <see cref_macro="MERGE_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_MERGE_END</b>
            </td>
            <td>
              <see cref_macro="MERGE_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_MSG_BEGIN</b>
            </td>
            <td>
              <see cref_macro="MSG_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_MSG_END</b>
            </td>
            <td>
              <see cref_macro="MSG_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_MSG_PAIR</b>
            </td>
            <td>
              <see cref_macro="MSG_PAIR"/>/<see cref_macro="SUB_MSG_PAIR"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_SB_BEGIN</b>
            </td>
            <td>
              <see cref_macro="SB_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_SB_END</b>
            </td>
            <td>
              <see cref_macro="SB_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_SB_LST_BEGIN</b>
            </td>
            <td>
              Replaced by <see cref_macro="SB_LST_REF_BEGIN"/>(<b>LIST_OF_SUBBLOCKS</b>, sub_blocks, "Sub Blocks", SB_COUNTER, ISIHDR_DONT_GENERATE)
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_SB_LST_END</b>
            </td>
            <td>
              Renamed to <see cref_macro="SB_LST_REF_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_SERVER_BEGIN</b>
            </td>
            <td>
              <see cref_macro="RES_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_SERVER_END</b>
            </td>
            <td>
              <see cref_macro="RES_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_SEQ_BEGIN</b>
            </td>
            <td>
              <see cref_macro="SEQ_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_SEQ_END</b>
            </td>
            <td>
              <see cref_macro="SEQ_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_SUB_MSG_BEGIN</b>
            </td>
            <td>
              <see cref_macro="SUB_MSG_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>DEFINE_SUB_MSG_END</b>
            </td>
            <td>
              <see cref_macro="SUB_MSG_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>FTD_TBL_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)<br/><see cref_macro="FTD_TBL_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>FTD_TBL_COMMENT_LINK</b>
            </td>
            <td>
              <see cref_macro="COMMENT_LINK"/>(LINK_TABLE, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>FTD_TBL_ENTRY_CONST</b>
            </td>
            <td>
              <see cref_macro="FTD_VALUE_BEGIN"/>
              <br/>
              <see cref_macro="VALUE_CONST"/>
              <br/>
              <see cref_macro="FTD_VALUE_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>FTD_TBL_ENTRY_CONST_VER</b>
            </td>
            <td>
              <see cref_macro="FTD_VALUE_BEGIN"/>
              <br/>
              <see cref_macro="VALUE_CONST"/>
              <br/>
              <see cref_macro="FTD_VALUE_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>FTD_TBL_ENTRY_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>FTD_TBL_ENTRY_TABLE</b>
            </td>
            <td>
              <see cref_macro="FTD_TABLE_BEGIN"/>
              <br/>
              general value macro
              <br/>
              <see cref_macro="FTD_TABLE_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>FTD_TBL_ENTRY_TABLE_VER</b>
            </td>
            <td>
              <see cref_macro="FTD_TABLE_BEGIN"/>
              <br/>
              general value macro
              <br/>
              <see cref_macro="FTD_TABLE_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>FTD_TBL_ENTRY_TABLE_CONST</b>
            </td>
            <td>
              <see cref_macro="FTD_TABLE_BEGIN"/>
              <br/>
              <see cref_macro="VALUE_CONST"/>
              <br/>
              <see cref_macro="FTD_TABLE_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>FTD_TBL_ENTRY_STRING</b>
            </td>
            <td>
              <see cref_macro="FTD_STRING"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>FTD_TBL_ENTRY_STRING_VER</b>
            </td>
            <td>
              <see cref_macro="FTD_STRING"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>INCLUDE_SHARED_FILE_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)<br/><see cref_macro="INCLUDE_SHARED_FILE"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>ISI_VERSION_COMMENT</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_CHANGE_DATE"/>, ...) and other versioning properties<br/><see cref_macro="ISI_VERSION_HISTORY"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>ITEM_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>ITEM_COMMENT_LINK</b>
            </td>
            <td>
              <see cref_macro="COMMENT_LINK"/>(link_type, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>ITEM_DEFAULT_VALUE</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_VALUE"/>(<see cref_property="PROPERTY_ITEM_DEFAULT_VALUE"/>, ...) or<br/><see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ITEM_DEFAULT_VALUE"/>, ...)<br/>
            </td>
          </tr>
          <tr>
            <td>
              <b>ITEM_LIMITS</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_VALUE"/>(<see cref_property="PROPERTY_ITEM_MINIMUM_VALUE"/>, ...) and/or<br/>
              <see cref_macro="PROPERTY_VALUE"/>(<see cref_property="PROPERTY_ITEM_MAXIMUM_VALUE"/>, ...) and/or<br/>
              <see cref_macro="PROPERTY_VALUE"/>(<see cref_property="PROPERTY_ITEM_EXCEPTIONAL_VALUE"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>ITEM_PARAMETER</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_PMD_PARAMETER"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>MON_TRACE_DEFINE_ID</b>
            </td>
            <td>
              <see cref_macro="TRACE_ID"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>MON_TRACE_DEFINE_ID_BEGIN</b>
            </td>
            <td>
              <see cref_macro="TRACE_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>MON_TRACE_DEFINE_ID_END</b>
            </td>
            <td>
              <see cref_macro="TRACE_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>MON_TRACE_ID_TBL_BEGIN</b>
            </td>
            <td>
              <see cref_macro="TRACE_GROUP_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>MON_TRACE_ID_TBL_END</b>
            </td>
            <td>
              <see cref_macro="TRACE_GROUP_END"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>MSG_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)<br/><see cref_macro="MSG_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>MSG_COMMENT_LINK</b>
            </td>
            <td>
              <see cref_macro="COMMENT_LINK"/>(LINK_MESSAGE, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>MSG_ID_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)<br/>see cref_macro="MSG_ID_SECTION"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>MSG_SET_TYPE</b>
            </td>
            <td>
              Replaced by the <i>type</i> argument to <see cref_macro="MSG_BEGIN"/>/<see cref_macro="SUB_MSG_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>NOTE_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)<br/><see cref_macro="NOTE"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>PARAMETER</b>
            </td>
            <td>
              <see cref_macro="PROPERTY"/>(<see cref_property="PROPERTY_PMD_PARAMETER"/>)
            </td>
          </tr>
          <tr>
            <td>
              <b>PPC_TBL_ENTRY_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>PPC_TBL_EMTRY_COMMENT_LINK</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_LINK, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>PROTOCOL_REF</b>
            </td>
            <td>
              <see cref_macro="BLOCK_REF"/>(BE, ..., BLOCK_PROTOCOL, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>RES_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)<br/><see cref_macro="RES_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>RES_COMMENT_LINK</b>
            </td>
            <td>
              <see cref_macro="COMMENT_LINK"/>(LINK_TYPE, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>RES_INCLUDE_SHARED_FILE</b>
            </td>
            <td>
              Replace with <see cref_macro="INCLUDE_SHARED_FILE"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>SB_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)<br/><see cref_macro="SB_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>SB_COMMENT_LINK</b>
            </td>
            <td>
              <see cref_macro="COMMENT_LINK"/>(LINK_SUBBLOCK, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>SB_LST_ENTRY_NAME</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_STRING"/>(<see cref_property="PROPERTY_ISIHDR_DEFINITION_NAME"/>, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>SB_REF</b>
            </td>
            <td>
              Replace with <see cref_macro="SEQ_OF"/>(..., 1)
            </td>
          </tr>
          <tr>
            <td>
              <b>SEQ_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)<br/><see cref_macro="SEQ_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>SEQ_COMMENT_LINK</b>
            </td>
            <td>
              <see cref_macro="COMMENT_LINK"/>(LINK_SEQUENCE, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>SERVER_SET_COMMON_MESSAGE_SUPPORT</b>
            </td>
            <td>
              Replaced by the <i>suppcomm</i> argument to <see cref_macro="RES_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>SERVER_SET_SHORT_NAME</b>
            </td>
            <td>
              Replaced by the <i>shortname</i> argument to <see cref_macro="RES_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>SERVER_SET_TYPE</b>
            </td>
            <td>
              Replaced by the <i>type</i> argument to <see cref_macro="RES_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>SUB_MSG_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)<br/><see cref_macro="SUB_MSG_BEGIN"/>
            </td>
          </tr>
          <tr>
            <td>
              <b>SUB_MSG_COMMENT_LINK</b>
            </td>
            <td>
              <see cref_macro="COMMENT_LINK"/>(LINK_MESSAGE, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>TBL_ENTRY_COMMENT</b>
            </td>
            <td>
              <see cref_macro="COMMENT"/>(COMMENT_TEXT, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>TBL_ENTRY_COMMENT_LINK</b>
            </td>
            <td>
              <see cref_macro="COMMENT_LINK"/>(link_type, ...)
            </td>
          </tr>
          <tr>
            <td>
              <b>VALUE_LIMITS</b>
            </td>
            <td>
              <see cref_macro="PROPERTY_VALUE"/>(<see cref_property="PROPERTY_ITEM_MINIMUM_VALUE"/>, ...) and/or<br/>
              <see cref_macro="PROPERTY_VALUE"/>(<see cref_property="PROPERTY_ITEM_MAXIMUM_VALUE"/>, ...) and/or<br/>
              <see cref_macro="PROPERTY_VALUE"/>(<see cref_property="PROPERTY_ITEM_EXCEPTIONAL_VALUE"/>, ...)
            </td>
          </tr>
        </table>
      </summary>
    </section>
  </topic>
  <topic name="Versioning" group="General">
    <summary>
      ISI interfaces change over time.
      New definitions are needed to support new features,
      and old definitions are removed when they are no longer needed.
      In order to keep track of these changes,
      interface versions are defined.
      <br/>
      This chapter discusses how these versions are described to autogen,
      and what use autogen makes of them.
    </summary>
    <section name="Interface versions in short">
      <summary>
        An interface version should not be confused with a server version.
        An interface version describes a particular collection of source files,
        where each source file exists in at most one version. Server versions are versions
        of the software that implements one or more interfaces.
        <br/><br/>
        An interface version, also called an ISI version,
        describes a particular collection of messages, sub blocks,
        constants and relations between these objects,
        where each object exist in at most one version.
        <br/><br/>
        In principle, an interface version has no relationship with the
        version of the software used to implement it.
        <br/>
        In practice, they are not independent,
        but the same software version may implement different interface versions,
        and the same interface version may be implemented by different software versions.
        <br/><br/>
        The message definitions for a given interface will generally contain definitions
        for exactly those interface versions that a given server version implements.
        <br/><br/>
        You might add more versions, and use the properties
        <see cref_property="PROPERTY_VERSION_NO_LONGER_SUPPORTED"/> and
        <see cref_property="PROPERTY_VERSION_NOT_YET_SUPPORTED"/> to prevent ISI header file
        clients from using the additional versions.
      </summary>
    </section>
    <section name="Selecting interface versions">
      <summary>
        In product environment, the file <b>isi_conf.h</b> is being used to control which
        interface version to use for each server.
        <br/>
        This file contains <b>#define</b>'s of the <b>Y</b> and <b>Z</b> version numbers
        for each resource, for which a specific interface version is requested.
        <br/><br/>
        Example of <b>isi_conf.h:</b>
        <code filename="versioning_isi_conf_macro.txt"/>
        These defines indicate to the server implementation, and to autogen,
        that the server should implement interface version 001.001.
        <br/>
        These defines are used to control conditional compilation of the interface header file,
        and possibly the implementation as well.
        <br/>
        For instance, a message that was first included in version 001.002 of the PoC
        interface will have its message ID or message structure inside
        <b>#if</b>/<b>#endif</b> that excludes it in version 001.001.
        <br/>
        In order for autogen to use this information,
        and it must be able to do so for correct results,
        you should include the following definitions in the start of you
        message definition file:
        <code filename="versioning_mdf_macro.txt"/>
        You must also use the <see cref_macro="RES_VERSION_STRING"/> macro to specify
        the default version of the server in the <see cref_macro="RES_BEGIN"/> macro.
        <br/>
        Interface version 001.002 is called the default version,
        since it's the version used by autogen if no other version is defined in
        <b>isi_conf.h</b>.
        <br/>
        In the ISI header files, autogen will generate similar definitions,
        aimed at providing a default version,
        even if no version is specified in <b>isi_conf.h</b>.
        <br/><br/>
        In local environment, autogen always uses the version specified in the
        message definition file, as <b>isi_conf.h</b> is not included here.
        This means that the PMD file in this environment will be based on default
        versions of the interfaces.
        <br/><br/>
        Please beware that leading zero(es) should never be used in
        <b>#define NNN_ISI_VERSION_n</b>!<br/>
        A leading zero causes the compiler to interpret the number as octal.
      </summary>
    </section>
    <section name="Specifying interface versions">
      <summary>
        Each interface version is specified using the
        <see cref_macro="ISI_VERSION_HISTORY"/> macro.
        It is customary to write extensive comments and to apply a number of properties,
        typically ISI version properties, to each interface version.
        <br/>
        autogen uses this information in the ISI header file header and in the HTML documentation.
        <br/><br/>
        An example of such a version history is given below:
        <code filename="isi_version_history_macro.txt"/>
        The version string "001.000" can now, without warnings,
        be used as <b>_verfrom</b> and <b>_verto</b> arguments to the various message macros.
        <br/><br/>
        It has proved to be a great help that the version numbers on files
        in Synergi match the default interface version specified in the message definition file.
        This goes both for the message definition file, and for any generated outputs
        such as the HTML files and the ISI header files.
        autogen puts the version number in the Synergi header in the ISI header files,
        but you must update it in Synergi yourself.
        <br/>
      </summary>
    </section>
    <section name="Specifying version intervals on objects">
      <summary>
        Supposing that you wanted to add a new indication message to
        version 002.000 of your interface.
        <br/><br/>
        The wrong way of doing it would be like this:
        <code filename="versioning_msg_wrong_macro.txt"/>
        The problem, of course, is that autogen thinks that this message has always been there.
        <br/>
        autogen only looks at one version of the message definition file,
        and has no idea what has changed since last autogeneration.
        <br/><br/>
        Not specifying the version causes the following problems:
        <br/>
        <ul>
          <li>
            The HTML documentation does not reflect that the message is only valid from version 002.000 onwards
            (unless you explicitly state this using <see cref_macro="COMMENT"/> macros,
            but that's a lot more work).
          </li>
          <li>
            The PMD file thinks that this message is valid,
            even if the version is downgraded.
            This means that you don't get error messages in you FastTrace output,
            even if clients attempt to use a downgraded version as if it was version 002.000.
          </li>
          <li>
            The version checking in autogen might think something is wrong.
          </li>
        </ul>
        <br/>
        There's nothing wrong with using "", "" as a version range,
        as long as the message is valid for all versions.
        <br/>
        If you've published an approved interface for version 001.000,
        you shouldn't change the interface afterwards,
        which is what you'd do with the sample above.
        So, in general, you'd only use "", "" until the interface is
        approved for the first time.
        <br/><br/>
        The right way of doing it is to tell autogen in what version the
        message appeared in the interface:
        <code filename="versioning_msg_right_macro.txt"/>
        This way, the autogen outputs will correctly reflect the fact that the
        message appeared in version 002.000.
      </summary>
    </section>
    <section name="Sub block versioning">
      <summary>
        A certain "referential integrity" is required for objects with different validity versions
        referring to each other.
        <br/>
        For instance, a message cannot use a constant table if that table is not valid for all
        versions where the message is valid.
        <br/>
        These integrity rules are generally intuitive.
        <br/><br/>
        For sub blocks, however,
        it is convenient if a new message version need not be made in order to allow
        a new sub block in that message.
        <br/>
        The macro <see cref_macro="SB_LST_ENTRY_VER"/> specifies, as <see cref_macro="SB_LST_ENTRY"/>,
        that a given sub block may occur in the enclosing sub block list.
        <br/>
        In addition, <see cref_macro="SB_LST_ENTRY_VER"/> specifies the version interval where the sub
        block may occur.
        This means, that the message definition from the later version can be used for
        the earlier version, without introducing a change in the earlier interface.
        <br/><br/>
        For instance, supposing that you have these definitions for version 001.000:
        <code filename="versioning_sb1_macro.txt"/>
        Fine. Then you add another sub block to the indication in version 001.002.
        Rather than making a new version of the message for version 001.002 (and including the new
        sub block in the sub block list), you can just use the following definitions:
        <code filename="versioning_sb2_macro.txt"/>
        A similar issue exists with <see cref_macro="CASE_VER"/> and
        <see cref_macro="CONST_TBL_ENTRY_VER"/>/<see cref_macro="DER_CONST_TBL_ENTRY_VER"/> macros.
      </summary>
    </section>
    <section name="Auto-generated version history">
      <summary>
        From version 006.001, autogen will generate version history for properly versioned
        objects (messages, tables, table entries, sub blocks, etc.) and add it at the top of
        the 'Description' fields of ISI header files and HTML documentation.
        <br/><br/>
        The purpose of this feature is to assist autogen users in producing correct and consistent
        object version documentation, thereby encouraging use of correct versioning of objects
        in the macro definition files.
        <br/>
        The auto generated version history does not remove or replace any information already in the
        macro definition file, but merely adds a list of findings based on version analysis of the
        file contents.<br/>
        Per default, autogen will auto generate version history for all versions of objects,
        but it is possible to specify from which interface version it should start,
        by using the property <see cref_property="PROPERTY_ISI_VERSION_AUTO_GENERATE"/>.
      </summary>
    </section>
    <section name="Applying versioning to unversioned items">
      <summary>
        Initially, most tables are defined using the non-versioned variant of the macro,
        e.g. <see cref_macro="CONST_TBL_ENTRY"/> and <see cref_macro="BIT_TBL_ENTRY"/>.
        <br/>
        Over time, some entries become obsolete, and new entries are added.
        Example of initial constant table:
        <code filename="versioning_applying1_macro.txt"/>
        We find a way to produce a more detailed status,
        and change the table accordingly in version 001.012:
        <code filename="versioning_applying2_macro.txt"/>
        Finally, we have found a way to do without the unspecific <b>MY_STATUS_FAIL</b>,
        and change the table accordingly in verion 002.000:
        <code filename="versioning_applying3_macro.txt"/>
        Note that the comment has been moved to a separate <see cref_macro="COMMENT"/>,
        macro as <see cref_macro="CONST_TBL_ENTRY_VER"/> does not support comments.
      </summary>
    </section>
    <seealso cref_macro="ISI_VERSION_HISTORY"/>
    <seealso cref_property="PROPERTY_ISI_VERSION_AUTO_GENERATE"/>
    <seealso cref_property="PROPERTY_VERSION_NO_LONGER_SUPPORTED"/>
    <seealso cref_property="PROPERTY_VERSION_NOT_YET_SUPPORTED"/>
  </topic>
  <topic name="Feature flags" group="General">
    <summary>
      Feature flags provide a method to control which parts of a resource that should be included in a build
      depending on flags. This will allow a build to remove all definitions not relevant for the build in 
      the given configuration.<br/>
      By using feature flags it is possible to do e.g. build specific tailoring of an interface by for example 
      reducing the number of supported messages. This does not require a special version of the interface to be
      made, but only flags to be activated or de-activated.
    </summary>    
    <section name="Defining a feature flag">
      <summary>
        Feature flags are supported by a number of macros used to define the areas that should be under flag.
        The following macros exists:<br/>
        <ul>
        <li>FEATURE_FLAG_DEFINED(_flag, _value)</li>
        <li>FEATURE_FLAG_DEFINED_OR_DEFINED(_flag1, _value1, _flag2, _value2)</li>
        <li>FEATURE_FLAG_DEFINED_AND_DEFINED(_flag1, _value1, _flag2, _value2)</li>
        <li>FEATURE_FLAG_ELSE()</li>
        <li>FEATURE_FLAG_END()</li>
        </ul>
        The following example shows how the feature flag macros can be used:
        <code filename="featureflag_macros.txt"/>
        This will generate the following ISI header.
        <code filename="featureflag_macros-isi.txt"/>
        In the above example a lot of flags have been used. In this case to demonstrate the various macros but in 
        general it is recommended to try and avoid making the macro files too complicated using feature flags.
        <br/>
        The documentation generated for the above macro file will look like the page at the following 
        <a href="Examples/featureflag_macros-html.txt">link</a>.<br/>
        In general a feature flag that is written just above a HTML table will show that all items in table is
        under this flag. Items in a structure can also be under flag. Each of such items will in the HTML table 
        be marked with a small tag. This is a reference and link to the actual feature flag written out just below
        the HTML table.
        <br/><br/>
        The macros will generate code in the form <b>#if (flag == value)</b> but using a special construction the feature
        flag can be constructed like <b>#ifdef flag</b> or as <b>#ifndef flag</b>.<br/>
        <code filename="featureflag_ex_if-def-flag.txt"/>
        The generated code will look like this
        <code filename="featureflag_ex_if-def-flag-isi.txt"/>
        Notice that the actual flag in FEATURE_FLAG_DEFINED() must be prepended with <b>AUTOGEN_</b> and the value 
        must be <b>ON</b> for a <b>#ifdef flag</b> to be generated and <b>OFF</b> for a <b>#ifndef flag</b> to be 
        generated.
      </summary>
    </section>
    <section name="Feature flags and XML">
      <summary>
        The XML output generated from the following macro file demonstrates how feature flags are represented in XML.<br/>
        <br/>
        Macro file:<br/>
        <code filename="featureflag_mac.txt"/>
        Generated XML output:<br/>
        <code filename="featureflag_xml.txt"/>
        Note that often the flags are define like this in the macro file:<br/>
        <pre>
          #define FLAG_A 0
          #define FLAG_B 2
        </pre>
        This knowledge are not automatically transferred to the generated XML file. But a trick is to define two
        CONSTANT().<br/>
        <pre>
          CONSTANT(FLAG_A, FLAG_A)
          CONSTANT(FLAG_B, FLAG_B)
        </pre>
        This way autogen is made aware of the two constants as can be seen in the above XML output.
      </summary>
    </section>
    <section name="Scopes">
      <summary>
        It is possible to use feature flags within the scope of a resource and within messages, 
        sub-messages, sub blocks, sequences, const tables and bit tables.
      </summary>
    </section>
    <seealso cref_macro="FEATURE_FLAG_DEFINED"/>
    <seealso cref_macro="FEATURE_FLAG_DEFINED_AND_DEFINED"/>
    <seealso cref_macro="FEATURE_FLAG_DEFINED_OR_DEFINED"/>
    <seealso cref_macro="FEATURE_FLAG_ELSE"/>
    <seealso cref_macro="FEATURE_FLAG_END"/>
  </topic>
  <topic name="Properties" group="General">
    <summary>
      Properties guide the behaviour of autogen whenever non-default processing is desired.
      <br/>
      Properties must be placed before the object they should affect.
      <br/><br/>
      The following property types are defined:
      <ul>
        <li>
          <b>Boolean property</b> (set with <see cref_macro="PROPERTY"/>)<br/>Simply applies a property
        </li>
        <li>
          <b>String property</b> (set with <see cref_macro="PROPERTY_STRING"/>)
        </li>
        <li>
          <b>String-Multiple property</b> (set with <see cref_macro="PROPERTY_STRING"/>)<br/>The property can be set several times on an object
        </li>
        <li>
          <b>String-Indexed property</b> (set with <see cref_macro="PROPERTY_STRING_INDEX"/>)
        </li>
        <li>
          <b>Value property</b> (set with <see cref_macro="PROPERTY_VALUE"/>)
        </li>
        <li>
          <b>Value-Multiple property</b> (set with <see cref_macro="PROPERTY_VALUE"/>)<br/>The property can be set several times on an object
        </li>
        <li>
          <b>Value-Indexed property</b> (set with <see cref_macro="PROPERTY_VALUE_INDEX"/>)
        </li>
      </ul>
    </summary>
  </topic>
  <topic name="Comments" group="General">
    <summary>
      Comments can be defined to basically any object (message, sub block, sequence, trace, item).
      Comments must be placed before the object to which the they relate.
      <br/><br/>
    </summary>
    <section name="Defining comments">
      <summary>
        Comments are constructed from simple comment elements. The following elements are supported:
        <br/>
        <ul>
          <li>
            Text paragraphs, using the macro <see cref_macro="COMMENT"/> with the type <b>COMMENT_PARAGRAPH</b>.
            A paragraph ensures that the text starts on a new line in HTML/ISI header file.
          </li>
          <li>
            Text, using the macro <see cref_macro="COMMENT"/> with the type <b>COMMENT_TEXT</b>. As paragraphs, but without line break.
          </li>
          <li>
            Line break, using the macro <see cref_macro="COMMENT"/> with the type <b>COMMENT_NEWLINE</b>.
          </li>
          <li>
            Links to notes and other robjects, using the macro <see cref_macro="COMMENT_LINK"/>.
          </li>
          <li>
            Properties, enabling/disabling comments in HTML/ISI header files, using the macro <see cref_macro="COMMENT_PROPERTY"/>.
          </li>
        </ul>
        <br/>
        Example of a comment definition:
        <code filename="comments_macro.txt"/>
        which generates the following in the ISI header file
        <code filename="comments_isihdr.txt"/>
        In the HTML document, similar comment is generated, with a link to the note from the text in addition.
      </summary>
    </section>
  </topic>
  <topic name="Sub blocks" group="General">
    <summary>
      A sub block is a specialised sequence (see <see cref_topic="Sequences"/>), where certain rules are applied.
      Sub blocks are mainly used to support optional/dynamic information in ISI messages.
      <br/>
      Besides, sub blocks represent common structures,
      which can be reused across an interface (e.g. messages share sub blocks).
      <br/><br/>
    </summary>
    <section name="Defining a sub block">
      <summary>
        Every sub block must have an ID field as first item. This ID is defined with the <see cref_macro="REFERENCE"/> macro,
        using <b>SB_ID</b> as reference name.
        <br/>
        In order to obey the ISA rules, sub blocks should also contain a length field.
        Again, this is defined with the <see cref_macro="REFERENCE"/> macro, using <b>SB_LENGTH</b> as reference name.
        <br/>
        Non-ISI sub blocks, can use the property <see cref_property="PROPERTY_SB_LENGTH_MISSING"/>,
        if the sub block contains no length field.
        For standard ISI sub blocks, the <see cref_macro="COMMON_SB"/> macros can be used to define sub block ID and length.
        <br/><br/>
        Generally, the length of a sub block must be divisible by 4.
        This is checked by autogen and a warning will be given if this criteria is not fulfilled.
        However, this check can be disabled by applying the property
        <see cref_property="PROPERTY_SB_LENGTH_NOT_DIVISIBLE_BY_4"/> to the sub block.
        <br/><br/>
        Sub blocks are defined using the <see cref_macro="SB_BEGIN"/>/<see cref_macro="SB_END"/> macros.
        <br/><br/>
        Example of a simple sub block definition:
        <code filename="subblocks_sb_macro.txt"/>
        Same example, using <see cref_macro="COMMON_SB"/>:
        <code filename="subblocks_sb_common_macro.txt"/>
      </summary>
    </section>
    <section name="Insertion of sub blocks in messages">
      <summary>
        When inserting sub blocks in messages (or in other sub blocks, as nested sub blocks are supported),
        a sub block list is typically defined.
        The list contains the sub blocks that are possible in the given context.
        <br/>
        Two types of lists exist:
        <ul>
          <li>The number of sub blocks is dynamic (typical use)</li>
          <li>The number of sub blocks is fixed (rare use)</li>
        </ul>
        <br/>
        Defining sub block lists of the two kind is explained in next sections.
        <br/><br/>
        It is also possible just to insert a specific sub block, as a nested structure,
        using the macro <see cref_macro="SEQ_OF"/>.
        <br/><br/>
        Example:
        <code filename="subblocks_insert_fixed_macro.txt"/>
        Note that 1 means one occurence. a number greater than 1 is passed,
        an array of the sub blocks is inserted.
        <br/>
        Using the macro <see cref_macro="SEQ_OF_REF"/>, and array of a
        specific sub block can be defined, when the number of array elements is dynamic.
      </summary>
    </section>
    <section name="List of sub blocks, when number of sub blocks is dynamic">
      <summary>
        When the number of sub blocks is dynamic, there are a few ways to determine the actual number of sub blocks.
        In all cases, the sub block list is defined using the
        <see cref_macro="SB_LST_REF_BEGIN"/>/<see cref_macro="SB_LST_END"/> macros.
        <see cref_macro="SB_LST_REF_BEGIN"/> requires a reference name, identifying the number of sub blocks.
        <br/><br/>
        <b>Number or sub blocks is defined in the message as a sub block counter</b>
        <br/><br/>
        The sub block counter must be defined with the macro <see cref_macro="REFERENCE"/>,
        and the reference name defined here is passed as reference name to <see cref_macro="SB_LST_REF_BEGIN"/>.
        <br/><br/>
        Example:
        <code filename="subblocks_list_ref_macro.txt"/>
        Note that limits can be defined for the number of sub blocks by applying the properties
        <see cref_property="PROPERTY_ITEM_MINIMUM_VALUE"/> and <see cref_property="PROPERTY_ITEM_MAXIMUM_VALUE"/>
        to the <see cref_macro="REFERENCE"/> macro.
        <br/><br/>
        <b>Number or sub blocks is not specified</b>
        <br/><br/>
        If the sub block list is defined in a message,
        the number of sub blocks is calculated from the PhoNet length.
        If the list is placed in another sub block, the number of sub blocks is calculated
        from the sub block length of the parent sub block.
        <br/>
        To define this, the reference name <b>REF_AS_MANY_AS_POSSIBLE</b> must be passed
        to <see cref_macro="SB_LST_REF_BEGIN"/>.
        <br/><br/>
        Example:
        <code filename="subblocks_list_amap_macro.txt"/>
        <br/>
        <b>Number or sub blocks can be 0 or 1</b>
        <br/><br/>
        This is a specialisation of the case above, where only 0 or 1 sub block can be present.
        <br/>
        To define this, the reference name <b>REF_OPTIONAL</b> must be passed
        to <see cref_macro="SB_LST_REF_BEGIN"/>.
        <br/><br/>
        Example:
        <code filename="subblocks_list_opt_macro.txt"/>
      </summary>
    </section>
    <section name="List of sub blocks, when number of sub blocks is fixed">
      <summary>
        When the number of sub blocks is fixed, the macros <see cref_macro="SB_LST_BEGIN"/>/
        <see cref_macro="SB_LST_END"/> should be used.
        <br/><br/>
        Example of a sub block list definition, where exactly one sub block is always present:
        <code filename="subblocks_list_fixed_macro.txt"/>
      </summary>
    </section>
  </topic>
  <topic name="Sequences" group="General">
    <summary>
      Sequences are collections of items, and is to be thought of as C structures.
      As the C language supports nested structures, autogen supports nested sequences.
      <br/>
      Messages, traces and sub blocks are specialised types of sequences,
      where special rules are applied.
      <br/>
      The rules apply to the types of items allowed,
      as well as size (in bits) and position within the sequence.
      <br/><br/>
      Standard sequences are defined using <see cref_macro="SEQ_BEGIN"/>/<see cref_macro="SEQ_END"/> macros.
      A typical use is for defining <see cref_topic="Arrays"/> and for reusing blocks
      of items between messages and/or sub blocks.
    </summary>
    <section name="Simple sequences">
      <summary>
        Simple sequences are sequences containing one element only.
        These sequences are only used for defining simple arrays (e.g. arrays of bytes).
        The elements must be either numbers or strings.
        <br/><br/>
        Example of simple sequence definition:
        <code filename="sequences_simple_macro.txt"/>
        The sequence does not generate a direct output in the ISI header file.
        <br/><br/>
        To ease defining simple arrays, the following predefined sequences can be used:
        <br/><br/>
        <table>
          <tr>
            <th>AUTOGEN_SEQ_BYTE_DEC</th>
            <th>AUTOGEN_SEQ_BYTE_HEX</th>
            <th></th>
            <th></th>
          </tr>
          <tr>
            <td>AUTOGEN_SEQ_WORD_DEC (BE)</td>
            <td>AUTOGEN_SEQ_WORD_DEC_BE</td>
            <td>AUTOGEN_SEQ_WORD_DEC_LE</td>
            <td>AUTOGEN_SEQ_WORD_DEC_NATIVE</td>
          </tr>
          <tr>
            <td>AUTOGEN_SEQ_WORD_HEX (BE)</td>
            <td>AUTOGEN_SEQ_WORD_HEX_BE</td>
            <td>AUTOGEN_SEQ_WORD_HEX_LE</td>
            <td>AUTOGEN_SEQ_WORD_HEX_NATIVE</td>
          </tr>
          <tr>
            <td>AUTOGEN_SEQ_DWORD_DEC (BE)</td>
            <td>AUTOGEN_SEQ_DWORD_DEC_BE</td>
            <td>AUTOGEN_SEQ_DWORD_DEC_LE</td>
            <td>AUTOGEN_SEQ_DWORD_DEC_NATIVE</td>
          </tr>
          <tr>
            <td>AUTOGEN_SEQ_DWORD_HEX (BE)</td>
            <td>AUTOGEN_SEQ_DWORD_HEX_BE</td>
            <td>AUTOGEN_SEQ_DWORD_HEX_LE</td>
            <td>AUTOGEN_SEQ_DWORD_HEX_NATIVE</td>
          </tr>
        </table>
        <br/>
        When <see cref_topic="Using 64-bit macros"/> the following predefined sequences can also be used:<br/><br/> 
        <table>
          <tr>
            <td>AUTOGEN_SEQ_DDWORD_DEC_BE</td>
            <td>AUTOGEN_SEQ_DDWORD_DEC_LE</td>
            <td>AUTOGEN_SEQ_DDWORD_DEC_NATIVE</td>
          </tr>
          <tr>
            <td>AUTOGEN_SEQ_DDWORD_HEX_BE</td>
            <td>AUTOGEN_SEQ_DDWORD_HEX_LE</td>
            <td>AUTOGEN_SEQ_DDWORD_HEX_NATIVE</td>
          </tr>
        </table>
        <br/>
      </summary>
    </section>
    <section name="Complex sequences">
      <summary>
        Complex sequences are sequences containing more than one element.
        Defining arrays of complex sequences is only possible when the sequence is a structure.
        Therefore the sequence flag must be <b>CREATE_STRUCT</b> in these situations.
        <br/><br/>
        Example of complex sequence definition:
        <code filename="sequences_complex_macro.txt"/>
        which generates the following in the ISI header file:
        <code filename="sequences_complex_isihdr.txt"/>
      </summary>
    </section>
  </topic>
  <topic name="Device endianess" group="General">
    <summary>
      This section describes device endianess and how it is used and configured in <b>autogen</b>.
    </summary>
    <section name="What is endianess?">
      <summary>
        All CPUs use a specific endianess when storing data in memory. Endianess is the way a data entity (more
        than one byte) is stored in memory and two methods are used: Little endianess (LE) and big endianess (BE).<br/>
        If a CPU uses 16 bit words (eg. value = 0x1EC0) the bytes can be laid out in memory as:<br/>
        <ul>
          <li>
            hi-byte, lo-byte (example: 1E, C0)<br/>
            The word is laid out in big endian format
          </li>
          <li>
            lo-byte, hi-byte (example: C0, 1E)<br/>
            The word is laid out in little endian format
          </li>
        </ul>
        Endianess is an important issue when data is exchanged between different types of CPUs. Two
        different types of CPUs do not necessarily store data in the same endianess. To be able to interpret
        the data correctly the format of exchanged data must be agreed. Example: In ISI messages all data fields
        are ordered in big endian.<br/>
        When tracing internal data or protocol messages this may all be little endian, but it is carried by an ISI message for
        interpretation by FastTrace running on desktop PC.<br/>
        Here is it important to know in what endianess the has be written in order to interpret it correctly.
      </summary>
    </section>
    <section name="Using endianess in autogen macros">
      <summary>
        Most autogen message macros used when writing message and trace specifications allow specification of endianess.<br/>
        An example of a macro is
        <ul>
          <li>VALUE(16, BE, data, "Data", HEX)</li>
        </ul>
        The 'BE' means that the value should be stored in big endian format.<br/>
        <br/>
        The following values can be used for specifying endianess in autogen:
        <ul>
          <li>BE - Big endian.</li>
          <li>LE - Little endian.</li>
          <li>NATIVE - Use the native endianess of the phone device.</li>
        </ul>
        The value 'NATIVE' forces endianess to be the native endianess of the target device. <br/><br/>
        When autogen generates a PMD file it will need to know the actual endianess of the target device whether it
        is little endian or big endian. Otherwise FastTrace (using the PMD file) will not be able to decode
        trace messages from the device correctly.<br/>
        The flag <b>AUTOGEN_DEVICE_ENDIANESS</b> is used to specify what NATIVE means.<br/><br/>
        <b>AUTOGEN_DEVICE_ENDIANESS</b> can be set to one of the following values:
        <ul>
          <li>AUTOGEN_DEVICE_ENDIANESS_BE</li>
          <li>AUTOGEN_DEVICE_ENDIANESS_LE</li>
        </ul>
        and it forces NATIVE to be considered 'BE' (big endian) or 'LE' (little endian).
        This flag may be defined in the file <b>autogen_conf.h</b>.<br/><br/>
        If this flag <b>AUTOGEN_DEVICE_ENDIANESS</b> is not defined then the default behaviour is to consider
        NATIVE to be 'LE' unless one of the following two flags have been defined: 'UPP_8M' or 'UPP_V2'.<br/>
        In this case NATIVE will be considered 'BE'.<br/><br/>
        Additional information can be found here: <see cref_enum="E_ORDER_TYPE"/>.
      </summary>
    </section>
    <section name="Predefined simple sequences">
      <summary>
        All predefined simple types are specified in BE (default), but also as LE and NATIVE.<br/>
        AUTOGEN_SEQ_WORD_DEC, AUTOGEN_SEQ_WORD_DEC_BE, AUTOGEN_SEQ_WORD_DEC_LE, AUTOGEN_SEQ_WORD_DEC_NATIVE.<br/>
        AUTOGEN_SEQ_WORD_HEX, AUTOGEN_SEQ_WORD_HEX_BE, AUTOGEN_SEQ_WORD_HEX_LE, AUTOGEN_SEQ_WORD_HEX_NATIVE.<br/>
        AUTOGEN_SEQ_DWORD_DEC, AUTOGEN_SEQ_DWORD_DEC_BE, AUTOGEN_SEQ_DWORD_DEC_LE, AUTOGEN_SEQ_DWORD_DEC_NATIVE.<br/>
        AUTOGEN_SEQ_DWORD_HEX, AUTOGEN_SEQ_DWORD_HEX_BE, AUTOGEN_SEQ_DWORD_HEX_LE, AUTOGEN_SEQ_DWORD_HEX_NATIVE.<br/>
      </summary>
    </section>
    <section name="16-bit SB_ID, MSG_ID, and Trace ID">
      <summary>
        When making DEVICE builds and using PMD_FILE_FORMAT 501 or higher little endian (LE) is supported. Example:<br/>
        <code filename="sb_id_native_macro.txt"/>
      </summary>
    </section>
  </topic>
  <!-- 
=======================================================================================
 Resources
======================================================================================= 
-->
  <topic name="PhoNet resources" group="Resources">
    <summary>
      PhoNet resources are resources (servers) having a resource ID defined in <b>pn_const.h</b>,
      and are characterised by using a message format,
      consisting of a PhoNet header and message ID as 7th byte.
      <br/><br/>
      All current PhoNet resources are part of the Connectivity Layer.
    </summary>
    <section name="Messages">
      <summary>
        PhoNet Message definitions must contain an 8-bit message ID as first byte.
        Sub messages are also supported, and require a sub message ID as second byte.
        <br/><br/>
        Message items must be correctly aligned, meaning that 16-bit items must be placed at even addresses
        and 32-bit items must be placed at 32-bit aligned addresses.
        <see cref_macro="FILLER"/> macro can be used to add fillers to ensure correct alignment.
        autogen will print warnings to <b>autogen.log</b> when items are not correctly aligned.
        <br/><br/>
        Messages are defined using <see cref_macro="MSG_BEGIN"/>/<see cref_macro="MSG_END"/> macros,
        and sub messages are defined using <see cref_macro="SUB_MSG_BEGIN"/>/<see cref_macro="SUB_MSG_END"/> macros.
        <br/>
        Note that <see cref_macro="COMMON_MSG_HDR"/> can't be used with PhoNet messages,
        as these do not contain transaction ID's.
      </summary>
    </section>
    <seealso cref_macro="RES_BEGIN"/>
  </topic>
  <topic name="PhoNet-Extended resources" group="Resources">
    <summary>
      PhoNet-Extended resources are identical to <see cref_topic="PhoNet resources"/> with the only
      exception that PhoNet-Extended resources contain messages on a format consisting of PhoNet header
      and receiver/sender object ID's.
    </summary>
    <seealso cref_macro="RES_BEGIN"/>
  </topic>
  <topic name="ISI resources" group="Resources">
    <summary>
      ISI resources are resources (servers) having a resource ID defined in <b>pn_const.h</b>
      or at least a product specific resource ID defined, and are characterised by using a message format,
      consisting of a PhoNet header and receiver/sender object ID's.
      <br/><br/>
      For an example of a message defintion file for an ISI resource,
      see <see cref_example="Template file for ISI resources"/>.
      <br/><br/>
      Some special resource ID's have their own resource type, as additional rules etc. are applied for these.
      <ul>
        <li>
          <b>PN_MEDIA_CONTROL</b> has it's own resource type <b>RESOURCE_ISI_MEDIA_CONTROL</b>
        </li>
        <li>
          <b>PN_PRIVATE</b> has it's own resource type <b>RESOURCE_ISI_PRIVATE</b>. See <see cref_topic="ISI private resources"/>
        </li>
        <li>
          <b>PN_PREFIX</b> has it's own resource type <b>RESOURCE_ISI_PREFIX</b>. See <see cref_topic="ISI prefix resources"/>
        </li>
      </ul>
    </summary>
    <section name="Resource definition">
      <summary>
        To define the ISI resource, the following must be passed to <see cref_macro="RES_BEGIN"/>:
        <br/>
        - Resource type must be <b>RESOURCE_ISI</b>
        <br/>
        - Resource ID must be the PhoNet resource ID, e.g. <b>PN_CALL</b>!
      </summary>
    </section>
    <section name="Resource extensions">
      <summary>
        ISI resource can be split in logically different resources, e.g. two resources, sharing same resource ID.
        To do so, one ISI resource must be the main resource for the resource ID,
        and the other(s) are so-called ISI resource extensions
        (using resource type <b>RESOURCE_ISI_EXTENSION</b>).
        <br/><br/>
        See <see cref_topic="Extension resources"/> for a description of how to make such extensions.
      </summary>
    </section>
    <section name="Messages">
      <summary>
        ISI Message definitions must contain an 8-bit transaction as first byte and an 8-bit message ID as second byte.
        ISI Sub messages are also supported, and require a sub message ID as third byte.
        <br/><br/>
        Message items must be correctly aligned, meaning that 16-bit items must be placed at even addresses
        and 32-bit items must be placed at 32-bit aligned addresses.
        <see cref_macro="FILLER"/> macro can be used to add fillers to ensure correct alignment.
        autogen will print warnings to <b>autogen.log</b> when items are not correctly aligned.
        <br/><br/>
        Messages are defined using <see cref_macro="MSG_BEGIN"/>/<see cref_macro="MSG_END"/> macros,
        and sub messages are defined using <see cref_macro="SUB_MSG_BEGIN"/>/<see cref_macro="SUB_MSG_END"/> macros.
      </summary>
    </section>
    <section name="Sub blocks">
      <summary>
        ISI messages support sub blocks. These must contain a sub block ID item (8 or 16 bit)
        and a sub block length item (8 or 16 bit). Sub block ID items must be the first items in all
        sub block definitions.
        <br/><br/>
        Within a resource, the sub block ID items should have the same size, either 8 or 16 bit.
        <br/>
        The sub block length defines the length of the entire sub block, including header.
        <br/><br/>
        As sub blocks are kind of nested structures to the message structures,
        the sub blocks should be aligned correctly,
        meaning that the sub block length should be divisible by 4,
        and sub blocks are inserted at a 32-bit aligned addressed in the messages (or sub blocks).
        <br/><br/>
        Nested sub blocks are supported.
        <br/><br/>
        The <see cref_macro="SB_BEGIN"/>/<see cref_macro="SB_END"/> macros are used to define sub block
        definitions.
        <br/><br/>
        Note that sub blocks can be shared between resources.
        To do so, they must be placed in <see cref_topic="Shared resources"/>.
      </summary>
    </section>
    <seealso cref_macro="RES_BEGIN"/>
  </topic>
  <topic name="ISI private resources" group="Resources">
    <summary>
      ISI private resources are specialised ISI resources
      to be used for defining private interfaces on <b>PN_PRIVATE</b>.
      To define such interface, a unique 16-bit private ID must be required from CL.
      The following link should provide info on this: <a href="http://cowww02.europe.nokia.com/projects/isacoresw/cl/pn_private.htm" class="cref link">pn_private.htm</a>.
      <br/><br/>
      In general, all rules for <see cref_topic="ISI resources"/> are also valid for ISI private resources.
      <br/><br/>
      For an example of a message defintion file for an ISI private resource,
      see <see cref_example="Template file for private ISI resources"/>.
    </summary>
    <section name="Resource definition">
      <summary>
        To define the private ISI resource, the following must be passed to <see cref_macro="RES_BEGIN"/>:
        <br/>
        - Resource type must be <b>RESOURCE_ISI_PRIVATE</b>
        <br/>
        - Resource ID must be the 16-bit private ID, not <b>PN_PRIVATE</b>!
        <br/><br/>
        Example, showing the difference between defining the ISI private resource and a regular ISI resource:
        <code filename="resources_isi_priv_res_macro.txt"/>
      </summary>
    </section>
    <section name="Messages">
      <summary>
        In addition to transaction ID and message ID,
        private messages must contain a 16-bit private ID as well.
        <br/><br/>
        ISI Sub messages are not supported.
        <br/><br/>
        Example of a private ISI message definition:
        <code filename="resources_isi_priv_msg_macro.txt"/>
      </summary>
    </section>
    <section name="Accessing private object from PC">
      <summary>
        <b>PN_PRIVATE</b> is not a valid address,
        so object ID <b>PN_OBJ_ROUTING_REQ</b> can't be used as receiver object,
        when sending messages to the object.
        <br/>
        The only way to send messages to these objects is by using correct object ID as
        receiver object.
        <br/><br/>
        The property <see cref_property="PROPERTY_PMD_PHONET_OBJECT_ID"/> can be used to define
        the object ID (by name), associated with the private interface.
        <br/>
        When the PMD file is generated, the actual value is looked up in the
        auto-generated file <b>pn_obj_auto.h</b>.
        If the name is not found (due to misspell?), <b>PN_OBJ_ROUTING_REQ</b> is used,
        and this basically means that the object can't be accessed from PC!
        <br/><br/>
        This object ID information in the PMD file is used for encoding/sending messages using PMD.
        An example could be the PMD message sender in FastTrace.
      </summary>
    </section>
    <seealso cref_macro="RES_BEGIN"/>
  </topic>
  <topic name="ISI prefix resources" group="Resources">
    <summary>
      ISI prefix resources are specialised ISI resources
      to be used for defining interfaces on <b>PN_PREFIX</b>. They are used because we are running out of resource ID's. 
      When using <b>PN_PREFIX</b> as resource ID, and additional 16 bit resource ID is placed after the message ID in the message. 
      The actual value of the resource ID, defined in <b>pn_const.h</b> is then a combination of <b>PN_PREFIX</b> and the 16-bit extended resource ID. 
      The resource ID must be defined wityjh the macro <b>PN_RES</b>.
      <br/><br/>
      In general, all rules for <see cref_topic="ISI resources"/> are also valid for ISI prefix resources.
      <br/><br/>
      For an example of a message defintion file for an ISI prefix resource,
      see <see cref_example="Template file for prefix ISI resources"/>.
    </summary>
    <section name="Resource definition">
      <summary>
        To define the prefix ISI resource, the following must be passed to <see cref_macro="RES_BEGIN"/>:
        <br/>
        - Resource type must be <b>RESOURCE_ISI_PREFIX</b>
        <br/>
        - Resource ID must be the constant defined with the <b>PN_RES</b> macro in <b>pn_const.h</b>!
        <br/><br/>
        Example, showing the difference between defining the ISI prefix resource and a regular ISI resource:
        <code filename="resources_isi_prefix_res_macro.txt"/>
        The resource ID <b>PN_MY_SRV</b> could be defined like this in <b>pn_const.h</b>:
        <code filename="resources_isi_prefix_res2_macro.txt"/>
      </summary>
    </section>
    <section name="Messages">
      <summary>
        In addition to transaction ID and message ID,
        prefix messages must contain a 16-bit resource ID as well.
        <br/><br/>
        ISI Sub messages are not supported.
        <br/><br/>
        Example of a prefix ISI message definition:
        <code filename="resources_isi_prefix_msg_macro.txt"/>
        Example of a prefix ISI message definition (alternative):
        <code filename="resources_isi_prefix_msg2_macro.txt"/>
      </summary>
    </section>
    <seealso cref_macro="RES_BEGIN"/>
  </topic>
  <topic name="Generic protocol resources" group="Resources">
    <summary>
      autogen supports generic protocols. Generic protocols are theoretically any byte-based,
      non-PhoNet protocol.
      <br/><br/>
      HTML documentation is generated as for any other resource.
      PMD is only supported when the protocol is used within a PhoNet message or trace.
      Soon, PMD will support generic protocols, so any protocol defined with message
      macros can be decoded directly.
      <br/><br/>
    </summary>
    <section name="Require protocol ID">
      <summary>
        To define a generic protocol with message macros,
        a unique protocol ID must be obtained.
        <br/>
        Use an ID, not already in the table below,
        and send a mail to DSS with information about the protocol.
        DSS will then update the table accordingly.
        <br/><br/>
        Current supported protocols and reserved ID's:
        <br/>
        <table>
          <tr>
            <th>Name</th>
            <th>ID</th>
            <th>Contact</th>
          </tr>
          <tr>
            <td>PROTOCOL_PHONET</td>
            <td>0x00</td>
            <td>Stig H. Eliasen</td>
          </tr>
          <tr>
            <td>PROTOCOL_AI2_CMD_PACKETS</td>
            <td>0x01</td>
            <td>Jens Schwarzer</td>
          </tr>
          <tr>
            <td>PROTOCOL_AI2_RSP_PACKETS</td>
            <td>0x02</td>
            <td>Jens Schwarzer</td>
          </tr>
          <tr>
            <td>PROTOCOL_X_FILE</td>
            <td>0x03</td>
            <td>Stig H. Eliasen</td>
          </tr>
          <tr>
            <td>PROTOCOL_INVARIANT_TRACE</td>
            <td>0x04</td>
            <td>Stig H. Eliasen</td>
          </tr>
          <tr>
            <td>PROTOCOL_MODEM_L1_INTERNAL_MSGS</td>
            <td>0x05</td>
            <td>Juha Vasarainen</td>
          </tr>
          <tr>
            <td>PROTOCOL_EUTRAN_L2_INTERNAL_MSGS</td>
            <td>0x06</td>
            <td>Pasi Laitinen</td>
          </tr>
          <tr>
            <td>PROTOCOL_MCU_TRACE</td>
            <td>0x07</td>
            <td>Stig H. Eliasen</td>
          </tr>
          <tr>
            <td>PROTOCOL_SYMBIAN_TRACE</td>
            <td>0x08</td>
            <td>Stig H. Eliasen</td>
          </tr>
          <tr>
            <td>PROTOCOL_IPC_INTERNAL_MSGS</td>
            <td>0x09</td>
            <td>Antti Haapakangas (Nokia-D/Oulu)</td>
          </tr>
          <tr>
            <td>PROTOCOL_MEIF_MESSAGES</td>
            <td>0x0A</td>
            <td>Kimmo Alanen (Nokia-D/Tampere)</td>
          </tr>
          <tr>
            <td>PROTOCOL_PEIF_MESSAGES</td>
            <td>0x0B</td>
            <td>Kimmo Alanen (Nokia-D/Tampere)</td>
          </tr>
          <tr>
            <td>PROTOCOL_RANC_MSGS</td>
            <td>0x10</td>
            <td>Hannu S. Huusko (Nokia-D/Oulu)</td>
          </tr>
          <tr>
            <td>PROTOCOL_MACN_MSGS</td>
            <td>0x11</td>
            <td>Hannu S. Huusko (Nokia-D/Oulu)</td>
          </tr>
          <tr>
            <td>PROTOCOL_NOA_INTERNAL_MSGS</td>
            <td>0x12</td>
            <td>Mika.A Tervonen (Nokia-D/Oulu)</td>
          </tr>
          <tr>
            <td>PROTOCOL_LS_NPE_EVENT</td>
            <td>0x13</td>
            <td>Troels Riis (Nokia-D/Copenhagen)</td>
          </tr>
          <tr>
            <td>PROTOCOL_NOA_APPL_INTERNAL_MSGS</td>
            <td>0x14</td>
            <td>Tervonen Mika.A (Nokia-D/Oulu)</td>
          </tr>
          <tr>
            <td>PROTOCOL_LCIF</td>
            <td>0x20</td>
            <td>Jan Sundgaard Nielsen</td>
          </tr>
          <tr>
            <td>PROTOCOL_GERAN_INTERNAL_MSGS</td>
            <td>0x21</td>
            <td>nn</td>
          </tr>
          <tr>
            <td>PROTOCOL_PH_INTERNAL_MSGS</td>
            <td>0x22</td>
            <td>Gaurav Upadhyay (Nokia-D/Bangalore)</td>
          </tr>
        </table>
      </summary>
    </section>
    <section name="Resource definition">
      <summary>
        To define the protocol resource, the following must be passed to <see cref_macro="RES_BEGIN"/>:
        <br/>
        - Resource type must be <b>RESOURCE_PROTOCOL</b>
        <br/>
        - Resource ID must be the protocol ID
        <br/><br/>
        Example:
        <code filename="resources_prot_res_macro.txt"/>
      </summary>
    </section>
    <section name="Resource extensions">
      <summary>
        A protocol resource can be split in logically different resources,
        e.g. two resources, sharing same protocol ID.
        To do so, one protocol resource must be the main resource for the protocol ID,
        and the other(s) are so-called protocol resource extensions
        (using resource type <b>RESOURCE_PROTOCOL_EXTENSION</b>).
        <br/><br/>
        See <see cref_topic="Extension resources"/> for a description of how to make such extensions.
      </summary>
    </section>
    <section name="Messages">
      <summary>
        There are basically three rules for protocol messages.
        They must contain a message ID, which must be of same size (e.g. 8 bits)
        and placed at same offset in every message.
        <br/><br/>
        The following is supported in protocol messages:
        <ul>
          <li>Message ID's (8, 16, 24 or 32 bits) - placed at any (fixed) offset</li>
          <li>Sub message ID's (8, 16, 24 or 32 bits) - placed at any (fixed) offset</li>
          <li>Message length field (8, 16 or 32 bits) - placed at any (fixed) offset</li>
        </ul>
        <br/>
        Message length field is defined as a <see cref_macro="REFERENCE"/> with type <b>MSG_LENGTH</b>.
        Default, this length defines length of whole message including header.
        The property <see cref_property="PROPERTY_MSG_LENGTH_RELATES_TO_DATA_PART_ONLY"/> can be used with
        the message, if the length relates to the data part of the message only.
        <br/><br/>
        Example of a protocol message definition:
        <code filename="resources_prot_msg1_macro.txt"/>
        Another example:
        <code filename="resources_prot_msg2_macro.txt"/>
      </summary>
    </section>
    <section name="Using protocols">
      <summary>
        The macro <see cref_macro="BLOCK_REF"/> (with block type <b>BLOCK_PROTOCOL</b> defines that a a certain
        number of bytes should be decoded using a given protocol.
        <br/><br/>
        Example, showing how to define a MCU trace containing protocol data:
        <code filename="resources_prot_use_macro.txt"/>
        Note that if the protocol can't be resolved during autogen execution,
        the protocol data will simply be dumped as HEX when decoded with PMD.
        <br/><br/>
        Note also that the <see cref_macro="BLOCK_REF"/> macro can be used in any context (messages, traces).
      </summary>
    </section>
    <seealso cref_macro="RES_BEGIN"/>
    <seealso cref_macro="BLOCK_REF"/>
  </topic>
  <topic name="Media module resources" group="Resources">
    <summary>
      Media module resources define media module specific messages,
      which are communicated via media controller (<b>PN_MEDIA_CONTROL</b>).
      <br/><br/>
      When compiling media module resource definition files in autogen,
      it is necessary also to include the file <b>pn_media_isi_m.h</b>
      (located in <b>global_interface/ISI/Core</b>) in <b>autogen_local_server_conf.h</b>.
    </summary>
    <section name="Resource definition">
      <summary>
        To define the media module resource, the following must be passed to <see cref_macro="RES_BEGIN"/>:
        <br/>
        - Resource type must be <b>RESOURCE_MEDIA_MODULE</b>
        <br/>
        - Resource ID must be the PhoNet media ID, e.g. <b>PN_MEDIA_BT</b>
      </summary>
    </section>
    <section name="Resource extensions">
      <summary>
        A media module resource can be split in logically different resources,
        e.g. two resources, sharing same resource ID.
        To do so, one media module resource must be the main resource for the resource ID,
        and the other(s) are so-called media module resource extensions
        (using resource type <b>RESOURCE_MEDIA_MODULE_EXTENSION</b>).
        <br/><br/>
        See <see cref_topic="Extension resources"/> for a description of how to make such extensions.
      </summary>
    </section>
    <section name="Messages">
      <summary>
        Media module specific messages must contain an 8-bit message ID as first byte.
        Sub messages are also supported, and require a sub message ID as second byte.
        <br/><br/>
        Message items must be correctly aligned,
        meaning that 16-bit items must be placed at even addresses
        and 32-bit items must be placed at 32-bit aligned addresses.
        <see cref_macro="FILLER"/> macro can be used to add fillers to ensure correct alignment.
        autogen will print warnings to <b>autogen.log</b> when items are not correctly aligned.
        <br/>
        If messages are not alignbed (and should not be),
        alignment-check (and warnings) can be disabled for the resource
        using the property <see cref_property="PROPERTY_ALIGNMENT_CHECK_DISABLE"/>.
        <br/><br/>
        Messages are defined using <see cref_macro="MSG_BEGIN"/>/<see cref_macro="MSG_END"/> macros,
        and sub messages are defined using <see cref_macro="SUB_MSG_BEGIN"/>/<see cref_macro="SUB_MSG_END"/> macros.
      </summary>
    </section>
    <seealso cref_macro="RES_BEGIN"/>
  </topic>
  <topic name="Shared resources" group="Resources">
    <summary>
      By means of shared resources it is possible for servers to share declarations of tables and sub blocks.
      <br/>
      A shared resource must have the same version as the owner resource.
      <br/>
      Example, illustrating the use of sub block from shared resource:
      <br/>
      The shared resource:
      <code filename="sharedResourceDefinitions.txt"/>
      The owner resource:
      <code filename="sharedResourceOwner.txt"/>
      The client resource:
      <code filename="sharedResourceClient.txt"/>
    </summary>
    <seealso cref_macro="RES_BEGIN"/>
  </topic>
  <topic name="Extension resources" group="Resources">
    <summary>
      Resource extensions are, as the name implies, extensions to other resources.
      <br/><br/>
      Extensions can be used when interfaces grow large, so it makes sense to split it logically.
      Splitting an interface using extensions, has the following affect:
      <ul>
        <li>An ISI header file is generated for each logical part of the interface</li>
        <li>A HTML document is generated for each logical part of the interface</li>
        <li>Separate versioning of the logical interfaces is possible, if wanted.</li>
      </ul>
      <br/>
      When defining extensions, autogen will check that no message ID's etc.
      conflict across the different resource parts. Though splitting the interface,
      it is still the same resource ID...
      <br/><br/>
      Extension resource message macro files can be included in autogen without the base resource file,
      but in this situation, the will obviously be no checking across the interfaces
      (for overlapping message ID's etc.)
      <br/><br/>
      The following resources support extensions:
      <ul>
        <li>
          ISI resources (extension resource type is <b>RESOURCE_ISI_EXTENSION</b>)
        </li>
        <li>
          Media module resources (extension resource type is <b>RESOURCE_MEDIA_MODULE_EXTENSION</b>)
        </li>
        <li>
          Protocol resources (extension resource type is <b>RESOURCE_PROTOCOL_EXTENSION</b>)
        </li>
      </ul>
      <br/>
      The property <see cref_property="PROPERTY_INHERIT_BASE_RESOURCE_DEFINITIONS"/> can be used to allow resource extensions to refer 
      to the definitions (sequences and tables) directly in the macro files.
    </summary>
    <seealso cref_macro="RES_BEGIN"/>
  </topic>
  <topic name="Resource Legacy" group="Resources">
      <summary>
          The Resource Legacy is the â€œgraveyardâ€ of a resource: The place where macros go when they have become obsolete. From the point of view of ISI header file and HTML documentation anything placed in Legacy does not exist. In order to support more than just the latest version of the server interface, Legacy part is included when generating TSA and XML outputs.
          By moving obsolete macros to Resource Legacy (in a separate file) readability of â€œcurrentâ€ macro file can be improved and size of file reduced.
          <br/>
          Resource Legacy should be used when the message macro file of a server holds a large amount of obsolete objects â€“ kept there for backward compability reasons.
          In case the macro file holds one or more versions marked as â€˜no longer supportedâ€™, objects belonging to this/these version(s) are also candidates for being moved to Resource Legacy:
          <br/>
          PROPERTY(PROPERTY_VERSION_NO_LONGER_SUPPORTED)
          ISI_VERSION_HISTORY("001.000")
          <br/>
          The following types of objects can be moved to Resource Legacy:
          <ul>
              <li>
                  Versioned constants (CONSTANT_VER(â€¦))
              </li>
              <li>
                  Constant tables (CONST_TBL_BEGIN(â€¦))
              </li>
              <li>
                  BIT tables (BIT_TBL_BEGIN(â€¦))
              </li>
              <li>
                  Subblocks (SB_BEGIN(â€¦))
              </li>
              <li>
                  Messages (MSG_BEGIN(â€¦))
              </li>
              <li>
                  Sub messages (SUB_MSG_BEGIN(â€¦))
              </li>
          </ul>
          <br/>
          <b>How to include Resource Legacy</b>
          Resource Legacy must be included from the bottom of the message macro file of the originating resource, e.g.:
          <br/>
          â€¦
          <br/>
          RES_END
          <br/>
          #ifdef AUTOGEN_INCLUDE_LEGACY<br/>
          #include â€œtest_isi_legacy_m.hâ€<br/>
          #endif<br/>
          <br/>
          The flag â€˜AUTOGEN_INCLUDE_LEGACYâ€™ is controlled by autogen.
          <br/>
          Only one Resource Legacy can be included.<br/>
          It is not legal to include â€˜foreignâ€™ legacy. Attempting to do so will cause an error.
          <br/>
          <b>All resource types having a valid, non-private resource ID may have a Resource Legacy extension.</b>
          <br/><br/>
          <b>Naming Convention</b>
          <br/>
          Files containing Resource Legacy must be named as the message macro file of the originating resource, but with â€œ_legacyâ€ inserted before _m.h.
          Example:<br/>
          Message macro file name: camera_isi_m.h<br/>
          Name of file containing Resource Legacy: camera_isi_legacy_m.h.<br/>
          <br/>
          Version 001.000 is no longer to be supported, thus all objects marked obsolete up to and including version 001.000 are moved to Resource Legacy. Inclusion of the message macro file containing Resource Legacy must be done from the bottom of the originating message macro file!
          Example, illustrating the use of Resource Legacy:
          <br/>
          Original message macro file:
          <code filename="resource_legacy_main_nosplit.txt"/>
          Message macro file after split:
          <code filename="resource_legacy_split.txt"/>
          Corresponding legacy resource:
          <code filename="resource_legacy_legacy.txt"/>
          <br/>
          Note that PROPERTY(PROPERTY_VERSION_NO_LONGER_SUPPORTED) is <b>not</b> included in legacy.<br/>
          Please note that file containing Resource Legacy must be available along with macro file of originating resource!<br/>
      </summary>
    <seealso cref_macro="RES_BEGIN"/>
  </topic>
  <!-- 
=======================================================================================
 FTD data
======================================================================================= 
-->
  <topic name="FTD Concept" group="FTD data">
    <summary>
      This section describes the overall idea with the FTD concept in the products.
    </summary>
    <section name="Field Test Displays">
      <summary>
        FTDs, Field Test Displays, is a concept developed mainly for easy field testing
        and operator testing of products.
        <br/>
        Using the Net monitor in the product, a specific field test display can be shown.
        The displays typically print informational data from specific servers / components in the product.
      </summary>
    </section>
    <section name="Field Test Display data">
      <summary>
        The actual informational data in the displays are so-called field test display data,
        from now on referred to as FTD data.
        <br/><br/>
        Data can be informational, which is the typical scenario. Examples are battery temperature and
        neighbour channel strengths. However, some data can be sent to the product, as a kind of dynamic settings.
        Such data is referred to as FTD input data or FTD test data.
        <br/><br/>
        Within a server, the FTD data, test data as informational data, must be identified by a unique 16-bit FTD ID,
        which is used to communicate subscriptions and actual values through ISI common messages.
      </summary>
    </section>
    <section name="Subscribing to FTD data">
      <summary>
        FTD data can be subscribed with a server by sending a <b>COMM_FTD_DATA_REQ</b> message to the server.
        <br/>
        The activation message contains a list of FTD ID's of the required FTD data.
        The server replies with a response message containing a sub block for each of the requested data.
        The sub block ID is the FTD ID.
        <br/>
        With a certain frequency defined by the server, updated FTD data values will be sent to the client.
        <br/>
        FTD data subscriptions can be ended sending a <b>COMM_FTD_DATA_DEACTIVATE_REQ</b> message.
        <br/><br/>
        <i>Note that</i>...
        <ul>
          <li>
            each <b>COMM_FTD_DATA_REQ</b> message sent to a given server erase ealier FTD data subscriptions with that server
          </li>
          <li>
            a server can only have one subscriber to FTD data,
            hence Net monitor and FastTrace can't be used to display data from the same server simultaneously.
          </li>
          <li>some data is static, and will be returned just once. Example is battery type information, which hardly changes...</li>
        </ul>
      </summary>
    </section>
    <section name="Sending FTD input data">
      <summary>
        For sending FTD test data or FTD input data to a server, 
        the common ISI message <b>COMM_FTD_TEST_DATA_REQ</b> must be sent.
        One message can contain one data, represented as a 32-bit value.
        <br/><br/>
        The actual FTD test value is not always of interest, so in some situations,
        the FTD ID alone represents the command to send to server.
      </summary>
    </section>
    <section name="Classification of FTD data">
      <summary>
        As FTD data remain in the product in special SW builds for close and distant 3rd parties,
        such as operators, a sort of classification of data is needed.
        <br/>
        Most defined FTD data is for RD only, hence these are flagged out in the special builds.
        <br/><br/>
        PMD files can be generated for RD, infra-vendors (so-called resticted PMD files) and operators (so-called public PMD files). 
        For more information on these PMD files, please refer to <see cref_subtopic="PMD files" />.
        <br/><br/>
        FTD data goes into the PMD files according to the following table:
        <br/><br/>
        <table border="0">
          <tr>
            <td>
              <b>Customer</b>
            </td>
            <td>
              <b>FTD classification</b>
            </td>
            <td>
              <b>PMD file type</b>
            </td>
          </tr>
          <tr>
            <td>RD</td>
            <td>RD</td>
            <td>RD</td>
          </tr>
          <tr>
            <td>Close 3rd parties</td>
            <td>Infra</td>
            <td>Restricted</td>
          </tr>
          <tr>
            <td>Distant 3rd parties</td>
            <td>Operator</td>
            <td>Public</td>
          </tr>
        </table>
        <br/>
        The property <see cref_property="PROPERTY_FTD_SUPPORTED_MODES" /> can be set on the defined FTD data to classify them.
      </summary>
    </section>
  </topic>
  <topic name="Defining FTDs" group="FTD data">
    <summary>
      The following section describes how to define FTD data in message macro files
    </summary>
    <section name="General">
      <summary>
        FTD data must be defined in a FTD table within the resource definition of the message macro file.
        <br/><br/>
        Within the FTD table, the individual FTD data (informational data as test or input data) must be defined, each having a unique 16-bit FTD ID.
        <code filename="ftd_tbl_macro.txt"/>
        <br/>
        FTD data is classified for RD, infra-vendors and operators using the 
        property <see cref_property="PROPERTY_FTD_SUPPORTED_MODES" />. Default, FTD data is classified for RD only.
      </summary>
    </section>
    <section name="Defining simple FTD data">
      <summary>
        Simple FTD data are returned from the servers in common template sub blocks. 
        3 variants of sub block templates are supported for sending FTD data of 8, 16 and 32 bits. 
        <br/><br/>
        The actual FTD data is defined using normal <see cref_group="Item macros"/>, with some restrictions. 
        As the values are simple, references etc. can't be defined.
        <br/><br/>
        Example of a simple 32-bit FTD data definition, classified for operators:
        <code filename="ftd_data_simple_macro.txt"/>
        Example of a simple 8-bit FTD data definition, classified for operators:
        <code filename="ftd_data_simple_byte_macro.txt"/>
        Please note that <b>no filler bytes are required</b>: The byte is included right after Sub Block Length in the sub block carrying the data.
        This way 32-bit alignment is achieved without adding fillers.
        <br/><br/>
        Example of a complex 16-bit FTD data definition:
        <code filename="ftd_data_complex_macro.txt"/>
      </summary>
    </section>
    <section name="Defining FTD data as arrays of data">
      <summary>
        As for simple FTD data, three vaiants of arrays are supported; arrays of 8-bit, 16-bit and 32 bit values. 
        Defining array data is thereby analogue to simple data, just with another FTD macro.
        <br/><br/>
        Example of a definition of FTD data array of simple 32-bit values:
        <code filename="ftd_data_table_simple_macro.txt"/>
      </summary>
    </section>
    <section name="Defining FTD string data">
      <summary>
        Strings are quite easy to define. Both ASCII and Unicode strings are supported, 
        and which format to support is up the server.  Using a set of properties (see ewample), 
        minimum and maximum string lengths can be defined.
        <br/>
        When returning the string to the client, they are placed in a common template sub block, 
        which has a bit determining whether the actual string is in ASCII or Unicode.
        <br/>
        You don't need to define the chosen format in autogen, as PMD will decode the string based on the flag in the sub block.
        <br/><br/>
        Example of a FTD string data definition, classified just for RD:
        <code filename="ftd_string_data_macro.txt"/>
      </summary>
    </section>
    <section name="Defining test / input FTD data">
      <summary>
        FTD test data must always be defined as a 32-bit value. autogen / PMD let you split the value into several logical parts,
        as long as the sum of bits defined is always 32.
        <br/>
        If you just need part of the 32-bit or none (the value is not used), 
        you can use the <see cref_macro="FILLER" /> macro to fill up to 32-bit.
        <br/><br/>
        Example of a simple 32-bit FTD test data definition:
        <code filename="ftd_test_data_simple_macro.txt"/>
        Example of a FTD test data definition, where the value is not used at all. Classified for RD and infgra-vendors:
        <code filename="ftd_test_data_no_value_macro.txt"/>
        Example of a complex FTD test data definition, classified for operators:
        <code filename="ftd_test_data_complex_1_macro.txt"/>
        Another complex FTD test data definition:
        <code filename="ftd_test_data_complex_2_macro.txt"/>
      </summary>
    </section>
  </topic>
  <topic name="FTDs in FastTrace" group="FTD data">
    <summary>
      The following section describes how to use and test defined FTDs in FastTrace
    </summary>
    <section name="Activating FTD data">
      <summary>
        In FastTrace, open the PMD message sender and select the ISI resource to which the FTD data belongs.
        <br/>
        Select the message <b>COMM_FTD_DATA_REQ</b>. 
        In the <i>Number of asked FTD Data</i> field, select the number of data you require. 
        You must now fill out an array of IDs of the required FTD data. Do so and send the message.
        <br/><br/>
        Frequently, a notification is sent by the server including the values of the requested FTD data. The message is <b>COMM_FTD_DATA_RESP</b>.
        <br/><br/>
        Data can be unsubscribed again sending a <b>COMM_FTD_DATA_DEACTIVATE_REQ</b> message.
      </summary>
    </section>
    <section name="Making your own field test displays">
      <summary>
        In FastTrace, open the plug-in <b>GridView</b>. This plug-in allows you to configure your own 
        on-line displays. You can base the displays on FTD data, but also on other types of data such as trace data.
        <br/>
        The plug-in does not do any intelligent activation of the required data, this must be done manually.
      </summary>
    </section>
    <section name="Testing FTD test/input data">
      <summary>
        In order to send FTD test/input data to the product, 
        open the PMD message sender and select the ISI resource to which the FTD data belongs. 
        <br/>
        Double-click the ISI message <b>COMM_FTD_TEST_DATA_REQ</b> and its structure should be presented in the right pane of the PMD message sender dialog.
        In the message, the actual setting value(s) are marked with blue and require input. Enter / select values and send the message.
        <br/><br/>
        <i>Note that some FTD test data do not require any input (there are no blue fields), as the FTD data requires no parameters.</i>
        <br/><br/>
        We are working on another and better solution for sending these values...
      </summary>
    </section>
  </topic>
  <!-- 
=======================================================================================
 Traces
======================================================================================= 
-->
  <topic name="General trace structure" group="Traces">
    <summary>
      autogen supports a general and flexible way of defining traces and trace groups for trace concepts.
      Currently, the trace concepts <see cref_topic="MCU traces"/> and <see cref_topic="Symbian traces"/>
      use this way, and <see cref_topic="Invariant traces"/> concept possibly will too.
      <br/><br/>
      When using this system, very little is hardcoded to autogen / PMD solution for the individual trace concept.
      <br/><br/>
      For a trace concept, the traces and trace groups are defined in trace macro files.
      One or more files can be defined for a single concept.
      <br/><br/>
      In general, a trace macro file contains a resource definition (defines the actual trace type),
      containing a number of trace group definitions, again containing a number of trace definitions.
      <br/><br/>
      Example of trace macro file, using general trace macros:
      <code filename="general_trace_macro.txt"/>
      In the file, one trace group is defined, containing two traces. One with data, and one without.
      <br/><br/>
      For further descripion on the trace macros, see <see cref_group="Trace macros"/>.
    </summary>
    <section name="Trace identifiers">
      <summary>
        Trace identifiers are the 4-character wide identifier which is the first part of the PMD decoding (compact format).
        They should be used to easily idenfify a group / type of traces. By default, identifiers are defined for each
        trace types, so e.g. MCU traces are decoded with identifier "mcu".
        <br/><br/>
        Using the property <see cref_property="PROPERTY_PMD_TRACE_IDENTIFIER"/>, it is possible to overrule the default identifiers.
        <br/>
        If the property is used on the resource, all traces with the resource will be decoded with the identifier.
        <br/>
        If the property is used on a trace group, all traces within the trace group will be decoded with the identifier.
        <br/><br/>
        Note that this will property not have full effect until PMD file format 3.00 is released (after FastTrace 2.4 is released).
      </summary>
    </section>
    <section name="Trace flags">
      <summary>
        The macro <see cref_macro="TRACE_GROUP_BEGIN"/> takes as last argument a state,
        which must be either <b>ON</b> or <b>OFF</b>.
        Typically, this would be defined as a build flag.
        <br/><br/>
        How the value is defined depends on the trace concept.
      </summary>
    </section>
    <section name="Trace group ID's">
      <summary>
        The macro <see cref_macro="TRACE_GROUP_BEGIN"/> defines a trace group.
        It takes a trace group name as first argument.
        The macro supports two ways of defining the trace group ID's:
        <ul>
          <li>Trace group ID is fixed. Value is predefined (in some header file), and is passed to the macros</li>
          <li>Trace group ID is dynamic. Only the name is passed to the macros</li>
        </ul>
        <br/>
        The flag <b>AUTOGEN_TRACE_GROUPS_HAVE_FIXED_ID</b> determines how the macro is evaluated.
        It will be set in the autogen source where the trace macro files for the trace concepts are included.
        <br/><br/>
        If the flag is not defined, autogen will determine the actual trace group ID based on the
        include order of trace macro files and definition order of the trace groups.
        The first defined trace group gets ID 0x0001, the next 0x0002 and so forth.
      </summary>
    </section>
    <section name="Trace ID's">
      <summary>
        The macros <see cref_macro="TRACE_BEGIN"/> and <see cref_macro="TRACE_ID"/>
        define the actual traces in the groups. The first argument is the trace ID.
        Analog to the trace group macro, the macros support two ways of defining the trace ID's:
        <ul>
          <li>Trace ID is fixed. Value is predefined (in some header file), and is passed to the macros</li>
          <li>Trace ID is dynamic. Only the name is passed to the macros</li>
        </ul>
        <br/>
        The flag <b>AUTOGEN_TRACES_HAVE_FIXED_ID</b> determines how the macro is evaluated.
        This flag will also be set in the autogen source,
        but can be set in the trace macro files if some trace groups should be handled differently
        than the default way for the trace concept.
        <br/><br/>
        If the flag is not defined, autogen will determine the actual trace ID based on the
        position of the macro in the trace table. The first defined trace gets ID 0x0000, the next 0x0001 and so forth.
        <br/><br/>
        Example of trace group definition, which must have fixed trace ID's,
        and default behaviour for the trace concept is to have dynamically allocated  trace ID's:
        <code filename="general_trace_macro_fixed_id.txt"/>
      </summary>
    </section>
    <section name="Trace data">
      <summary>
        If a trace contains any data, the <see cref_macro="TRACE_BEGIN"/>/<see cref_macro="TRACE_END"/> variants
        of the trace macros mus be used to define the trace.
        <br/>
        Trace data is defined, as message elements in message macro defintions.
        The section <see cref_group="Item macros"/> includes a reference of the macros, possible to use for defining the data.
        As for interface macro files, tables of constants and sequences can be defined to provide a more
        complex trace data description.
      </summary>
    </section>
  </topic>
  <topic name="MCU traces" group="Traces">
    <summary>
      MCU traces are ISA MCU component traces, which can be enabled runtime from PC SW, e.g. FastTrace.
      Traces are only enabled in the code in R/D builds.
      <br/><br/>
      MCU traces are permanent traces, and should be part of the released code.
      Therefore, the traces should be defined efficiently,
      especially regarding memory consumption. In general, PMD should decode the trace data, not the phone itself!
      <br/><br/>
      Typical MCU traces for a component:
      <ul>
        <li>ISI messages received in component</li>
        <li>ISI messages sent from component</li>
        <li>State changes</li>
        <li>Functions being called</li>
      </ul>
      <br/>
      MCU traces are organised in groups. Besides from organising traces, groups also serve a purpose regarding trace activation.
      The Monitor server provides and interface for activating trace groups from PC SW.
      When activating a trace group, all traces within the group are activated.
      <br/><br/>
      The trace groups are defined in the file <b>mon_grp.ti</b>, which is a product configuration file.
      The traces in the individual groups are defined in component specific .ti files,
      typically named <b>xxx_mon.ti</b>, where <b>xxx</b> identifies the component,
      e.g. <b>em</b> for Energy Management.
      Please refer to the <see cref_example="Template file for MCU traces"/> for an example of a component specific .ti file.
      <br/><br/>
      A MCU trace ID is a unique 32-bit value, consisting of a 16-bit group ID (most significant word) and a 16 bit trace ID.
      <br/><br/>
      In autogen, MCU trace concept is handled as a generic trace concept,
      see <see cref_topic="General trace structure"/>.
      <br/><br/>
      For a description of adding trace support for a server, and examples,
      please refer to <see cref_subtopic="Adding traces to a component"/>.
      <br/><br/>
      For further descripion on the supported trace macros, see <see cref_group="Trace macros"/>.
    </summary>
  </topic>
  <subtopic name="New MCU trace concept" topic="MCU traces">
    <summary>
      The current MCU trace concept is quite complex to use for the developer,
      and causes many problems due to inconsistency.
      <br/>
      In short, the main problems with the current concept are:
      <br/><br/>
      <b>Configuration</b>
      <ul>
        <li>
          It is very difficult for a developer to add new trace groups and traces,
          and often several projects must be involved (entity, Monitor server and DSS).
        </li>
        <li>
          Configuring trace groups with traces is complex,
          and results in several unresolved trace group / trace relations in the products.
          Hence, traces can be activated but not decoded or can be decoded but not activated when using PMDâ€¦
        </li>
      </ul>
      <b>Consistency</b>
      <ul>
        <li>
          Occasionally, traces, which can be activated using PMD file,
          do not reflect the traces enabled in the product
        </li>
        <li>
          Occasionally, traces for features not enabled in the product can be activated
          (as PMD files contain them)
        </li>
      </ul>
      <br/>
      A new MCU trace concept has been approved in cooperation between DSS and WP
      (Core, Protocol and ISA UI).
      <br/>
      The new concept requires a changed .ti file format and trace flags.
      See the <see cref_example="Template file for MCU traces"/> for a correct .ti file,
      supporting the new trace concept.
      <br/><br/>
      The whole framework for the new concept is now ready,
      and the first components have already used the new way of defining traces.
      <br/><br/>
      Slides, describing the new trace concept in details.
      <table border="0">
        <tr valign="top">
          <td>
            <img src="pics/doctype_ppt.gif"/>
          </td>
          <td>
            <a href="docs/mcu_trace_concept_renewal_v0.7.ppt" class="cref link">mcu_trace_concept_renewal_v0.7.ppt - Updated on 22-Sep-2006</a><br/>
            Describes the reason for the new trace concept and general changes needed.
          </td>
        </tr>
        <tr valign="top">
          <td>
            <img src="pics/doctype_ppt.gif"/>
          </td>
          <td>
            <a href="docs/mcu_trace_concept_changes_v0.7.ppt" class="cref link">mcu_trace_concept_changes_v0.7.ppt</a> - Updated on 22-Sep-2006<br/>
            Describes the actual changes required from each component factory.
          </td>
        </tr>
      </table>
    </summary>
  </subtopic>
  <subtopic name="Adding traces to a component" topic="MCU traces">
    <summary>
      In general, adding MCU trace support to a server includes the following steps:
      <ul>
        <li>Defining component specific trace macros</li>
        <li>Defining trace functions (if needed)</li>
        <li>Defining trace interface file (.ti file)</li>
        <li>
          Adding trace flags to entity configuration file <b>mon_trace_conf_xxx.h</b>
        </li>
        <li>Adding trace interface file to build</li>
        <li>Adding traces to code</li>
      </ul>
      <br/>
      Below, each step is described, and an example is shown.
      The example is taken from <b>PN_HARDCORE</b> server,
      as trace support has been implemented recently in this server,
      and therefore the newest way of defining traces has been used.
      <br/><br/>
      The example shows the definition of two trace groups:
      <b>HARDCORE_MSG</b> (for tracing ISI messages received by the server and messages sent from the server) and
      <b>HARDCORE_FUNC</b> (for tracing entries of functions).
      <br/><br/>
      Please note, that the example is made for a CoreSW server,
      hence filename / flag name notation for CoreSW is followed.
    </summary>
    <section name="Defining component specific trace macros">
      <summary>
        In order to make it easy to add traces to the code,
        a set of trace macro should be defined for the component.
        The main purpose for these is only work when the trace flag(s) for the component are enabled.
        <br/><br/>
        In the example, a set of generic trace macros are defined to handle strings,
        primitives (bytes, words, dwords), trace ID only and ISI messages.
        <code filename="mcu_trace_example_hardcore_trace.h"/>
        Note that the function <b>mon_trace_on_check_msg_send</b> is used, so the monitor server only
        sends the data if the associated trace group is activated in extended mode.
        <br/><br/>
        If MCU performance is to be increased in the component (when tracing),
        the component could do the check itself (using the function <b>mon_trace_extended_on_check</b>,
        and only send the trace data to the monitor server, when needed.
      </summary>
    </section>
    <section name="Defining trace functions">
      <summary>
        If more complex traces are needed, such as traces containing ISI messages,
        a set of trace functions must be developed,
        as it would take too much space to expand complex macros.
        <br/><br/>
        For the example, a few functions must be implemented to support the ISI message tracing correctly.
        <code filename="mcu_trace_example_hardcore_trace.c"/>
        The resource ID must be set in the message before being traced, as the message without it will be incomplete,
        and can't be decoded with PMD.
      </summary>
    </section>
    <section name="Defining trace interface file (.ti file)">
      <summary>
        The trace groups and traces should be defined in the .ti file for the component using
        message macros.
        Most of the macros supported for message definitions are also available for trace definition.
        <br/><br/>
        Example, showing the trace definitions for Hardcore server, the file <b>hardcore_mon.ti</b>:
        <code filename="mcu_trace_example_hardcore_mon.ti"/>
      </summary>
    </section>
    <section name="Adding trace flags to entity configuration file">
      <summary>
        Trace flags basically makes it possible to enable/disable MCU trace groups at compile time,
        and thereby makes it possible to e.g. save memory/increase performance.
        <br/><br/>
        Flags can be set on group level only. Whether a flag is defined per group,
        or per component, and thereby enables/disables several groups, is up to the developer to deside.
        However, if there is no need to have flags on individual groups, don't do it.. because:
        <ul>
          <li>
            Every time you add/remove trace flags, you need to involve entity integtators,
            as the example trace configuration file for the entity must be updated.
          </li>
          <li>
            Every time an example trace configuration file changes,
            <b>all</b> product integrators must integrate the new entity example trace configuration file.
          </li>
        </ul>
        <br/>
        All trace flags must default to either <b>ON</b> or <b>OFF</b> in the .ti file, they are used in,
        as the code must be able to compile even when the trace configuration files are not updated!
        <br/>
        Whether to default as <b>ON</b> or <b>OFF</b> depends on the importance of the traces.
        Logically, flags for important traces should default to <b>ON</b>.
        <br/><br/>
        The following table shows the naming convension of the trace flags and the files, they must be be set in:
        <table>
          <tr>
            <th>Entity</th>
            <th>Flag names</th>
            <th>Responsible</th>
            <th>File</th>
          </tr>
          <tr>
            <td>Core SW</td>
            <td>TRACE_ICF_XXX</td>
            <td>Hannu Huotelin</td>
            <td>(example_)mcu_trace_conf_core.h</td>
          </tr>
          <tr>
            <td>Protocol SW</td>
            <td>TRACE_IPF_XXX</td>
            <td>Mikko Korpela</td>
            <td>(example_)mcu_trace_conf_protocol.h</td>
          </tr>
          <tr>
            <td>ISA UI SW</td>
            <td>TRACE_IUF_XXX</td>
            <td>Ville I. Pasanen</td>
            <td>(example_)mcu_trace_conf_isa_ui.h</td>
          </tr>
        </table>
        All trace code and trace definitions in the component must be defined under
        this/these trace flags.
        <br/><br/>
        Note that the example files are released from entities to products,
        and the product integrators then create the real files (normally just by copying the example files).
        <br/><br/>
        Trace flags used to be defined in <b>mon_trace_conf.h</b>, but that is not the case any more.
        Once the new MCU trace concept is in place, this file will be obsolete and removed from the builds.
        <br/><br/>
        Example of trace flag definition in <b>example_mcu_trace_core_conf.h</b>:
        <code filename="mcu_trace_example_trace_core_conf.h"/>
      </summary>
    </section>
    <section name="Adding trace interface file to build">
      <summary>
        In order for your .ti file to be included in the build,
        you need to involve the key-integration person within your entity.
        Below, the responsible integration persons are listed. The actual files,
        the .ti files should be in included in, are listed as well.
        <table>
          <tr>
            <th>Entity</th>
            <th>Responsible</th>
            <th>File</th>
          </tr>
          <tr>
            <td>Core SW</td>
            <td>Hannu Huotelin</td>
            <td>mcu_trace_core.h</td>
          </tr>
          <tr>
            <td>Protocol SW</td>
            <td>Mikko Korpela</td>
            <td>mcu_trace_protocol.h</td>
          </tr>
          <tr>
            <td>ISA UI SW</td>
            <td>Ville I. Pasanen</td>
            <td>mcu_trace_isa_ui.h</td>
          </tr>
        </table>
        Example:
        <code filename="mcu_trace_example_trace_core.h"/>
      </summary>
    </section>
    <section name="Adding traces to code">
      <summary>
        Traces are added, simply by using the component trace macros.
        <br/><br/>
        A typical trace point is the message handler, where messages are received, and responses sent back.
        <br/><br/>
        The example shows how (and where) these traces can be placed:
        <code filename="mcu_trace_example_hardcore_srv.c"/>
        Some places in the code, messages might be sent from a server, and here,
        the trace <b>HARDCORE_TRACE_MSG_SEND</b> should be inserted also.
      </summary>
    </section>
  </subtopic>
  <topic name="Invariant traces" group="Traces">
    <summary>
      Invariant traces is a new trace concept being developed in WP.
      As the name implies, traces and trace groups are defined with fixed ID's,
      and never changed, once defined. Even the trace data format is fixed and documented.
      This means that the traces in theory could be decoded by anybody.
      <br/><br/>
      Trace concept will be supported by several entities (e.g. GERAN and WRAN L1),
      each defining seperate trace macro files with trace group and trace definitions.
      In order for trace groups not to conflict between devices,
      trace groups must be ordered by entity, adding another grouping level,
      compared to the other supported trace concepts.
      <br/><br/>
      Even though trace format is fixed,
      it still makes sense to use PMD to decode the traces in Nokia R/D, hence autogen and
      message macros should support the trace concept.
      <br/><br/>
      In autogen, Invariant trace concept is handled as a generic trace concept,
      see <see cref_topic="General trace structure"/>.
    </summary>
    <section name="Invariant trace macro files">
      <summary>
        One invariant trace macro file must exist for each entity, supporting invariant traces.
        As the trace concept is general, an invariant trace macro file uses the general
        format. One exception is that the resource ID in the <see cref_macro="RES_BEGIN"/>,
        which typically is not used for trace resources, is taken into use to make the top level
        entity grouping.
        <br/><br/>
        Example of the macro file <b>invariant_trace_wran_l1_m.h</b> for the WRAN L1 entity:
        <code filename="invariant_trace_macro.txt"/>
        The macro files should be stored in <b>global_interface</b>,
        and HTML documents generated from the macro files should be stored in <b>GIF_SPECS</b>.
        <br/>
        Template file for invariant trace message macro files: <see cref_example="Template file for invariant traces"/>.
      </summary>
    </section>
    <section name="Invariant trace master file">
      <summary>
        Initially, one byte is allocated to define the trace entity ID's, allowing up to 256 possible entities.
        The file <b>inv_trace_prot_config.h</b> must define all the invariant trace entity ID's,
        as well as include all trace definitions.
        <br/><br/>
        Example of the master file:
        <code file="invariant_trace_master.txt"/>
        The master file as well must be stored in <b>global_interface</b>.
      </summary>
    </section>
    <section name="Including invariant trace macro files in autogen (Product environment)">
      <summary>
        In autogen, the file <b>autogen_invariant_trace.c</b> includes all invariant traces
        the following way:
        <code filename="invariant_trace_autogen.txt"/>
        Note the two flag definitions.
        The flags define that the trace macros should handle the trace group ID's
        and trace ID's as fixed values. See <see cref_topic="General trace structure"/> for further description.
      </summary>
    </section>
    <section name="Including invariant trace macro files in autogen (Local environment)">
      <summary>
        Generation of ISI headers, HTML documentation etc. is done in autogen in local environment.
        In this case the invariant trace macro file must be included via <b>autogen_local_server_conf.h</b>
        This can be done the following way:
        <code filename="invariant_trace_autogen_local.txt"/>
        Note the two flag definitions.
        The flags define that the trace macros should handle the trace group ID's
        and trace ID's as fixed values. See <see cref_topic="General trace structure"/> for further description.
      </summary>
    </section>
  </topic>
  <topic name="Symbian traces" group="Traces">
    <summary>
      In autogen, Symbian trace concept is handled as a generic trace concept,
      see <see cref_topic="General trace structure"/>.
    </summary>
  </topic>
  <topic name="DSP5 traces" group="Traces">
    <summary>
      DSP5 traces are DSP traces for BB5 products. First product supporting the traces was Chalie.
      The trace format was designed in cooperation between CDSP core team and DSS.
      Later on, ADSP adapted the same format, so all BB5 DSP traces now share same format.
      <br/><br/>
      All traces are defined with message macros,
      so trace decoding can be done with PMD and traces can be activated with PC tools, e.g. FastTrace.
      The following description is mostly related to CDSP traces as the trace macro
      files for CDSP are released to <b>wp_sw</b>, hence CDSP traces can be decoded with any PMD file
      generated from official BB5 product builds. ADSP still generate their own PMD files (July-2005).
    </summary>
    <section name="CDSP trace macro files">
      <summary>
        Most trace macro files for CDSP are hand made, but files for the CDSP signal traces are
        autogenerated from structures in .sig files with the tool <b>sig2macro</b>.
        This tool is developed by DSS and released as part of the autogen package.
        It is run as part of the CDSP build process,
        where it generates a trace macro file for each .sig file in the build.
        The trace macro files are compiled and all trace definitions end up in the generated PMD file.
      </summary>
    </section>
    <section name="Organization of traces">
      <summary>
        Currently, 40 trace groups are allocated for CDSP traces and the same for ADSP traces.
        Examples of CDSP trace groups are <b>CDSP Main Control</b> and <b>CDSP GSM Signals</b>.
        The actual traces have a 16-bit trace ID, unique across groups,
        so this limits a total of 65536 CDSP traces and 65536 ADSP traces.
        There are no restriction on the number of traces in each group.
        In addition, the traces can also be associated with logical groups,
        a kind og sub groups to the trace groups.
        <br/><br/>
        The following screen shot shows the trace activation dialog in FastTrace, where a PMD file containing DSP5 traces is loaded.
        On the left side, the CDSP trace groups are seen (together with other types of traces, such as MCU).
        On the right, the logical groups and actual traces for the selected trace group are shown.
        <br/><br/>
        <img src="pics/dsp5_trace_activation_02.gif"/>
        <br/><br/>
      </summary>
    </section>
    <section name="Activation of traces">
      <summary>
        Unlike MCU traces, DSP traces can be activated individually.
        The FastTrace activation dialog provides easy selection of all traces withing a logical group.
        Simply click within the logical group column.
        Some traces are activated as <b>ON</b>/<b>OFF</b>, and some as <b>ON</b>/<b>OFF</b>/<b>EXTENDED</b>.
        Typically, signals require the last activation method, where <b>EXTENDED</b>also dumps the
        content of the signals opposed to just the signal ID.
        <br/>
        Within a trace group, all traces must follow same activation scheme.
        <br/><br/>
        The following screen shot from the FastTrace trace activation dialog shows traces from a signal trace group,
        and diplays the difference in activation method from the trace group shown in the screen shot above.
        <br/><br/>
        <img src="pics/dsp5_trace_activation_01.gif"/>
        <br/><br/>
        To activate the traces, a <b>DSP_CORE</b> message must be sent to the target for each trace group.
        The message contains a trace group ID and also a bitmap with states for the individual traces in the group.
        <br/>
        If traces are activated as <b>ON</b>/<b>OFF</b>, one bit is required per traces, else two bits are required.
        See the section below how to define the actual activation method for a trace group.
        <br/><br/>
        Analog, an <b>ADSP_CORE</b> message must be sent to activate ADSP traces.
      </summary>
    </section>
    <section name="Defining DSP5 traces">
      <summary>
        DSP5 traces are defined as sub blocks, where the actual trace ID is the sub block ID.
        So defining the traces with message macros is basically the same as defing sub blocks for ISI messages.
        To define the relations to group and logical group for a trace,
        properties must be set on the trace sub block definition.
        The property <see cref_property="PROPERTY_PMD_TRACE_SOURCE"/> defines the trace group for a trace and the
        property <see cref_property="PROPERTY_PMD_TRACE_LOGICAL_GROUP"/> defines the logical trace group for a trace.
        <br/><br/>
        If, for some reason, the trace activation text for a trace should be different from the trace name (sub block ID),
        this can be defined with the property <see cref_property="PROPERTY_PMD_TRACE_ACTIVATION_TEXT"/>.
        <br/><br/>
        Some properties apply to the trace groups and not the traces themselves. As mentioned above,
        there are 40 traces groups available. How many groups are in use, what the groups are called and
        what traces they contain is totally configurable in the macro files.
        Nothing is hard coded to autogen except from the ID's of the 40 trace groups.
        The global group ID's (in autogen) are <b>PMD_MESSAGE_TYPE_DSP5_CDSP_1</b> to
        <b>PMD_MESSAGE_TYPE_DSP5_CDSP_40</b> for CDSP traces and <b>PMD_MESSAGE_TYPE_DSP5_ADSP_1</b> to
        <b>PMD_MESSAGE_TYPE_DSP5_ADSP_1</b> for ADSP traces.
        <br/>
        Many terms are used for the same thing. Mesage type, trace source, trace group and trace type
        are actually the same thing!
        <br/><br/>
        The properties for the trace groups can be set any place in any macro file,
        as they are kind of global properties.
        <br/><br/>
        To define a trace group name (trace type in the screen shots above),
        use the property <see cref_property="PROPERTY_PMD_TRACE_SOURCE_NAME"/>.
        <br/>
        For setting the activation method on the group (one bit or two bits per trace),
        the property <see cref_property="PROPERTY_PMD_TRACE_SOURCE_FLAGS"/> can be set.
        <br/>
        Finally, the 4-character trace identifier can be set for the trace group with the
        property <see cref_property="PROPERTY_PMD_TRACE_SOURCE_IDENTIFIER"/>.
        This is the string printed when decoding the traces in PMD compact format.
        <br/><br/>
        Typically, one trace macro file is made per trace group.
        The macro file should initially define the overall properties for the group
        and then define all the trace sub blocks.
        This file should then be included in the master macro file for DSP5 traces.
        <br/><br/>
        Example of a DSP5 trace macro file:
        <code filename="traces_dsp5_macro.txt"/>
        <br/>
        Example of the CDSP master trace macro file:
        <code filename="traces_dsp5_master.txt"/>
        The name of the CDSP master file is <b>dsp5_trc_m.h</b>. CDSP core are controlling the file,
        so they also control the actual trace group allocation -
        which trace group should be used for which entities.
      </summary>
    </section>
  </topic>
  <topic name="NOS traces" group="Traces">
    <summary>
      NOS traces (Nokia OS traces) are defined in the macro file <b>autogen_ostrich.h</b>,
      which is part of autogen releases and under DSS control.
      <br/><br/>
      If you encounter any problems with these (decode errors, missing trace definitions or simply ideas for improving decoding of these),
      please contact DSS.
      <br/><br/>
      Example of OS trace definition in <b>autogen_ostrich.h</b>:
      <code filename="nostraces_macro.txt"/>
    </summary>
  </topic>
  <topic name="XTI master SW traces" group="Traces">
    <summary>
      XTI masters are part of the XTI v3 concept. Here, each processor has a HW master ID, which will be passed in any trace message to PC. 
      Master ID must be used to distinguish traces from the different processors. 
      For each master, a message macro file must be implemented, defining the traces on that particular master.
      <br/><br/>
      Layout of XTI master macro file:
      <code filename="xti_master_macro.txt"/>
      <br/>
      The following trace types have been defined:
      <table>
        <tr>
          <th>Trace type</th>
          <th>ID</th>
          <th>Comment</th>
        </tr>
        <tr>
          <td>MASTER_TRACEBOX_MESSAGE</td>
          <td>0x00</td>
          <td>Reserved for trace box - phone communication</td>
        </tr>
        <tr>
          <td>MASTER_MCU_TRACE</td>
          <td>0x01</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_INVARIANT_TRACE</td>
          <td>0x02</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_HAL_TRACE</td>
          <td>0x03</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_NOS_TRACE</td>
          <td>0x04</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_ADSP5_TRACE</td>
          <td>0x05</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_CDSP5_TRACE</td>
          <td>0x06</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_SYMBIAN_TRACE</td>
          <td>0x07</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_OST</td>
          <td>0x08</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_HSP_TRACE</td>
          <td>0x09</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_ASCII_PRINTF</td>
          <td>0x20</td>
          <td>Standarsd trace formats</td>
        </tr>
        <tr>
          <td>MASTER_ASSERT</td>
          <td>0x21</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_CORE_DUMP</td>
          <td>0x22</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_RAW_DATA</td>
          <td>0x23</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_ASCII_PRINTF</td>
          <td>0x70</td>
          <td>Vendor traces</td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_COMPONENT_TRACE</td>
          <td>0x71</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_DLL_TRACE</td>
          <td>0x72</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_BINARY_TRACE_1</td>
          <td>0x73</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_BINARY_TRACE_2</td>
          <td>0x74</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_BINARY_TRACE_3</td>
          <td>0x75</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_BINARY_TRACE_4</td>
          <td>0x76</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_BINARY_TRACE_5</td>
          <td>0x77</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_BINARY_TRACE_6</td>
          <td>0x78</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_BINARY_TRACE_7</td>
          <td>0x79</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_BINARY_TRACE_8</td>
          <td>0x7A</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_BINARY_TRACE_9</td>
          <td>0x7B</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_BINARY_TRACE_10</td>
          <td>0x7C</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_BINARY_TRACE_11</td>
          <td>0x7D</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_BINARY_TRACE_12</td>
          <td>0x7E</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_VENDOR_BINARY_TRACE_13</td>
          <td>0x7F</td>
          <td></td>
        </tr>
        <tr>
          <td>MASTER_USER_TRACE_1</td>
          <td>0x80</td>
          <td>User traces</td>
        </tr>
        <tr>
          <td>MASTER_PN_MESSAGE</td>
          <td>0xFF</td>
          <td>PhoNet message</td>
        </tr>
      </table>
      <br/><br/>
      Note also that currently, the first byte of the transported data must be the trace type ID. 
      Eventually, it will be dynamic, so each master defines the size of the trace type ID.
    </summary>
  </topic>
  <topic name="XTI master HW traces" group="Traces">
    <summary>
      XTI master HW traces are part of the XTI v3 concept. Master HW traces <b>does not</b> support the 'Trace type ID' field used by master SW traces.
      This puts some restrictions on Master HW traces:
      <ul>
        <li>All Master IDs in a DEVICE build must be unique. This includes both SW and HW Master IDs</li>
        <li>If a HW Master ID collides with a SW Master ID then the decoding of the SW Master ID will not work</li>
        <li>Only one master HW trace can be specified for each Master ID</li>
        <li>The trace ID must be identical to the Master ID</li>
        <li>For each master HW trace, a message macro file must be implemented, defining the trace for that particular master</li>
        <li>It is possible to build several master HW traces into the same DEVICE PMD file along with master SW traces</li>
        <li>To distinguish master HW traces from master SW traces a property must be applied to each master HW resource:
      <code filename="xti_master_hw_property.txt"/>
        </li>
      </ul>
      <br/><br/>
      Example showing specification and implementation of 2 master HW traces:
      <br/>
      <table>
        <tr>
          <th>MPSS ID</th>
          <th>MPSS Target</th>
          <th>XTI ID</th>
          <th>Trace type</th>
        </tr>
        <tr>
          <th>...</th>
          <th>...</th>
          <th>...</th>
          <th>...</th>
        </tr>
        <tr>
          <th>15</th>
          <th>CORTEXR4_TCM</th>
          <th>Tapster HW Trace</th>
          <th>HW Trace</th>
        </tr>
        <tr>
          <th>16</th>
          <th>MPSS_Common_BUS1_ID</th>
          <th>Hamsa HW Trace 1</th>
          <th>HW Trace</th>
        </tr>
        <tr>
          <th>...</th>
          <th>...</th>
          <th>...</th>
          <th>...</th>
        </tr>
      </table>
      <br/><br/>
      Master HW macro file for Tapster HW Trace:
      <code filename="xti_master_hw_tapster_macro.txt"/>
      <br/><br/>
      Master HW macro file for Hamsa HW Trace 1:
      <code filename="xti_master_hw_hamsa_macro.txt"/>
      <br/><br/>
      Corresponding autogen_conf.h file:
      <code filename="xti_master_hw_autogen_conf_h.txt"/>
      <br/><br/>
      The master HW traces appear in FastTrace message view as:
      <code filename="xti_master_hw_message_view.txt"/>
      <br/><br/>
      Tapster master HW trace in FastTrace Detailed PMD view:
      <code filename="xti_master_hw_tapster_detailed_view.txt"/>
      <br/><br/>
      Hamsa 1 master HW trace in FastTrace Detailed PMD view:
      <code filename="xti_master_hw_hamsa_1_detailed_view.txt"/>
      <br/><br/>
    </summary>
  </topic>
  <topic name="Chipset supplier DLL traces" group="Traces">
    <summary>
      The Vendor DLL Traces concept is designed to support vendor specific traces in FastTrace. The concept defines how 
      to activate, send and decode traces.<br/>
      Activation is done by having the vendor implement two API functions, chipset_trace_activation_set() and 
      chipset_trace_activation_get(), which is used by the Monitor Server to set and retrieve the trace activation mask.
      A XML file (Chipset Supplier Description) describes how trace activation is organized in the vendor code.<br/>
      This Chipset Supplier Description is used by autogen to add information to the PMD file about how FastTrace should
      trace activate and decode the vendor traces.<br/>
      Sending traces is done by vendor calling the vendor_trace_send() function in the Monitor Server provided by Nokia. 
      Decoding of traces is done by FastTrace calling a decoding DLL implemented by the vendor and using the PMD file generated
      by autogen.
    </summary>
    <section name="Chipset Supplier Description file">
      <summary>
        The trace activation description file (Chipset Supplier Description) is an XML file created by the vendor to 
        describe how the vendor traces are activated.<br/>
        <br/>
        This is an example of an XML file that describes 13 trace groups, divided into 2 categories and the version of 
        the Chipset Supplier Description file is 0100.
        <code filename="chipset_supplier_description.txt"/>
        The Chipset Supplier Description is given as input to autogen which will generate a PMD file containing the above 
        information. This PMD file is then used by FastTrace to activate the various trace groups and to route vendor 
        traces down into the relevant vendor decoding DLLs.
      </summary>
    </section>
    <section name="Description of the elements of the Chipset Supplier Description">
      <summary>
        <table border="0">
          <tr><th>XML tag</th><th>XML attribute</th><th>Description</th></tr>
          <tr>
            <td>ChipsetSupplierDescription</td>
            <td>ChipsetSupplierId</td>
            <td>Each vendor must have his own unique identifier that identifies his collection of traces. This identifier is 
                specified in this attribute.<br/> 
                Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>ChipsetSupplierName</td>
            <td>This is the name of the chipset vendor. Used as presentation name various places.<br/> 
                Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>TraceMask</td>
            <td>-</td>
            <td>This section contains all information relevant for trace activation and specification of DLLs used to decode 
                the vendor traces.<br/>
                This is section is optional.</td>
          </tr>
          <tr>
            <td>TraceVersionMask</td>
            <td>-</td>
            <td>This section specifies the version number of this XML file. This version number is sent along with the trace 
                mask to the phone when activating the trace groups from FastTrace. The version number can consist of up to 8 bytes.<br/> 
                This section is optional.</td>
          </tr>
          <tr>
            <td>TraceCategory</td>
            <td>-</td>
            <td>This section specifies all the trace groups that are handled by a single decoding DLL.<br/>
                There must be one or more of these sections.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>Name</td>
            <td>Name of category. This name will be seen in the FastTrace trace activation screen.<br/>
            Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>LogicalName</td>
            <td>Logical name of category.<br/>
            Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>Id</td>
            <td>Unique identifier for the category. This value will also be sent as part of the trace activation bitmask. 
                The value must be between 0 â€“ 65535. Please see below for where it is located in the trace activation bitmask.<br/>
                Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>DLLName</td>
            <td>This attribute is used for constructing the DLL file name. Used for naming the DLL.<br/>
                Filename of DLL is constructed as (ChipsetSupplierName)_(DLLName)_(DLLVersionMajor)_(DLLVersionMinor).dll.<br/>
                Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>DLLVersionMajor</td>
            <td>This attribute is used for constructing the DLL file name. This represents the major part of the version number 
                and must be a three digit decimal number.<br/>
                Filename of DLL is constructed as (ChipsetSupplierName)_(DLLName)_(DLLVersionMajor)_(DLLVersionMinor).dll.<br/>
                Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>DLLVersionMinor</td>
            <td>This attribute is used for constructing the DLL file name. This represents the minor part of the version number 
                and must be a three digit decimal number.<br/>
                Filename of DLL is constructed as (ChipsetSupplierName)_(DLLName)_(DLLVersionMajor)_(DLLVersionMinor).dll.<br/>
                Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>Function</td>
            <td>Name of the function that FastTrace calls on the DLL. The actual DLL function name must be â€˜fn(name)Traceâ€™ as 
                autogen prepends â€˜fnâ€™ and appends â€˜Traceâ€™ to the name specified in the XML file.<br/>
                Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>Restriction</td>
            <td>Can take 3 possible values:
                <ul>
                  <li>RD</li>
                  <li>Restricted</li>
                  <li>Public</li>
                </ul>
                Used to control which trace categories that should be part of a PMD file.<br/>
                When autogen is executed it will generate a PMD file that contains more or less information depending on the 
                restriction it runs with. See <see cref_subtopic="PMD files"/>. It can run with the following restrictions: RD, Restricted or Public.
                <ul>
                  <li>If autogen is generating a RD PMD file then all trace categories will be included.</li>
                  <li>If autogen is generating a Restricted PMD file then only Restricted and Public trace categories 
                      are included in the PMD file.</li>
                  <li>If autogen is generating a Public PMD file then only Public trace categories are included.</li>
                </ul>
                Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>TraceGroupBit</td>
            <td>-</td>
            <td>Specifies the existence of a given trace group.<br/>
            There must be one or more of these sections.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>Name</td>
            <td>Name of the trace group. This will be seen in the FastTrace trace activation screen.<br/>
            Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>LogicalName</td>
            <td>Logical name of the trace group. This will be seen in the FastTrace trace activation screen.<br/>
            Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>Id</td>
            <td>Identifier of the trace group. This also denotes the bit position in bit mask for this trace group. 
                Note that the first bit in the trace mask has Id = 0.<br/>
                Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>CrashDump</td>
            <td>-</td>
            <td>This section describes a DLL that will be used to decode a crash dump.<br/>
                There can be 0 or more of these sections.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>Id</td>
            <td>The identifier of a given crash dump.<br/>
                The attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>DLLName</td>
            <td>This attribute is used for constructing the DLL file name. Used for naming the DLL.<br/>
                Filename of DLL is constructed as (ChipsetSupplierName)_(DLLName)_(DLLVersionMajor)_(DLLVersionMinor).dll.<br/>
                Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>DLLVersionMajor</td>
            <td>This attribute is used for constructing the DLL file name. This represents the major part of the version number 
                and must be a three digit decimal number.<br/>
                Filename of DLL is constructed as (ChipsetSupplierName)_(DLLName)_(DLLVersionMajor)_(DLLVersionMinor).dll.<br/>
                Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>DLLVersionMinor</td>
            <td>This attribute is used for constructing the DLL file name. This represents the minor part of the version number 
                and must be a three digit decimal number.<br/>
                Filename of DLL is constructed as (ChipsetSupplierName)_(DLLName)_(DLLVersionMajor)_(DLLVersionMinor).dll.<br/>
                Attribute is mandatory.</td>
          </tr>
          <tr>
            <td>-</td>
            <td>Function</td>
            <td>Name of the function that FastTrace calls on the DLL.<br/>
                Attribute is mandatory.</td>
          </tr>
        </table> 
        A XML schema can be found in the autogen directory and is called ChipsetSupplierDescription.xsd.
      </summary>
    </section>
    <section name="Trace activation of vendor DLL traces">
      <summary>
        When FastTrace has read the PMD file generated using the Chipset Supplier Description above, the vendor trace 
        part of the FastTrace trace activation dialog will show the 2 categories each containing the relevant trace 
        groups represented by the "TraceGroupBit" elements. The trace group names shown in the dialog are taken directly 
        from the "TraceGroupBit Name" attributes. The trace groups will be divided into 2 categories with the names given 
        by the "ChipsetSupplierName" concatenated with "TraceCategory Name". The user may select any or all of the trace 
        groups, and the information is translated to a bitmask per trace category that is passed to the vendor through 
        the chipset_trace_activation_set() function.<br/>
        <br/>
        When sending trace activation messages, the XML file above is translated into a bitmask (and a trace activation 
        message) for each trace category. To recognize which trace category a given bitmask belongs to the trace category 
        identifier is sent along with the bitmask.<br/>
        <br/>
        A bit mask for a single trace activation message (one trace category) is shown below. In this example the version is "0100", 
        the trace category is 1 and the following Modem trace groups are activated: Bit 0(RR), Bit 2(WRAN) and Bit 7(GSM).<br/>
        The Modem bits are set or reset depending on which trace groups are being activated by the user.
        <code filename="trace_activation_bitmask.txt"/>      
        When the chipset_trace_activation_get() function is called the vendor must return the bitmask in the same format 
        as shown in the bitmask example above.
      </summary>
    </section>    
    <section name="Decoding of vendor DLL traces">
      <summary>
        Vendor DLL traces are MASTER TRACES of type MASTER VENDOR DLL TRACE. This trace type contains a 32 bit field 
        called "SupplierId TraceCategoryId". This must be assigned the value of the 16 bit Chipset Supplier Identifier
        (upper 16 bit of the 32 bit value) and the relevant 16 bit TraceCategory Identifier (lower 16 bit). 
        Note that this is big endian format. The following shows an example that will match a supplier id of 12 and trace
        category id of 1 when being decoded by FastTrace.
        <code filename="supplierid_trccatid_bitmask.txt"/>
        FastTrace uses this information together with the information in the
        Chipset Supplier Description to determine which DLL a vendor trace message should be routed to when received in 
        FastTrace.<br/>
        <br/>
        If the "SupplierId TraceCategoryId" field is not set to a valid value according to the Chipset Supplier Description
        then FastTrace will print out the hex values or route the received vendor trace message to a default DLL 
        depending on configuration. See description of AUTOGEN_VENDOR_DLL_TRACE_DLL_FILE_NAME and 
        AUTOGEN_VENDOR_DLL_TRACE_DLL_FUNCTION_NAME<br/>
      </summary>
    </section>    
    <section name="Enabling vendor DLL traces in autogen">
      <summary>
        A number of flags control the addition of vendor traces in autogen. These flags can be defined
        in the autogen configuration file named <b>autogen_conf.h</b>. An example file is provided with
        autogen: <b>example_autogen_conf.h</b>.<br/>
        This standard configuration for vendor builds can be enabled with the flag ICF_CHIPSET_API == ON.<br/>
        <br/>
        Below is a short description of a few other important flags and defines:<br/>
        <table border="0">
          <tr><th>Flag</th><th>Description</th></tr>
          <tr>
            <td>AUTOGEN_INCLUDE_VENDOR_TRACES</td>
            <td>This enables various forms of vendor traces. Must be defined to include support for vendor DLL traces.</td>
          </tr>
          <tr>
            <td>AUTOGEN_INCLUDE_VENDOR_DLL_TRACE</td>
            <td>This flag tells that support for vendor DLL traces should be compiled in to autogen.<br/>
                This must always be set to support vendor DLL traces.</td>
          </tr>
          <tr>
            <td>AUTOGEN_USE_CHIPSET_SUPPLIER_DESCRIPTION</td>
            <td>This flag enables the support of Chipset Supplier Descriptions.<br/>
                (If this is not enabled then an obsolete method is enabled that only support one vendor DLL and no trace 
                activation.)</td>
          </tr>
          <tr>
            <td>AUTOGEN_VENDOR_DLL_TRACE_DEC_RES_TRC_MASTER</td>
            <td>This defines the name of the Resource Trace Master in which the vendor DLL traces are defined.<br/>
                <br/>
                Decoding of vendor DLL traces are specified in the PMD file in a resource of type â€˜Resource Trace Masterâ€™. 
                For autogen to automatically append decoding instructions corresponding to the contents of the Chipset 
                Supplier Description XML file, it must know the name of this resource.<br/>
                This name must be defined in AUTOGEN_VENDOR_DLL_TRACE_DEC_RES_TRC_MASTER.<br/>
                <br/>
                This resource trace master name is likely defined in autogen_server_conf.h in a macro construction like 
                this:
                <pre>
                PROPERTY_VALUE(PROPERTY_PMD_PHONET_DEVICE_ID, PN_DEV_HOST)
                PROPERTY_STRING(PROPERTY_PMD_TRACE_IDENTIFIER, "mcu")
                RES_BEGIN(RESOURCE_TRC_MASTER, XTI_MASTER_MCU, MASTER_MCU, "MCU Master", "", FALSE)
                RES_END</pre><br/>
                The name to use is XTI_MASTER_MCU.<br/>
                <br/>
                If autogen can not locate the specified name then autogen will print an error message on the screen 
                like this:<br/>
                "Resource Trace Master definition '(name)' not found".
            </td>
          </tr>
          <tr>
            <td>AUTOGEN_VENDOR_DLL_TRACE_GROUP_FILE_NAME</td>
            <td><b>Obsolete</b> - See below this table for description of including Chipset Supplier Descriptions into autogen<br/>
                This specifies the location of the Chipset Supplier Description XML file. If using a relative path then
                it is relative to the current working directory when executing the autogen executable. (This will typically
                be the .../coretools/autogen/ directory)<br/>
                Note that this allows only to import <b>one</b> Chipset Supplier Description.
            </td>
          </tr>
          <tr>
            <td>AUTOGEN_VENDOR_IDENTIFIER</td>
            <td>Used by various vendor traces to specify the trace identifier.
                The trace identifier is a 4 character name, which is displayed when a trace is decoded with PMD in compact format. 
                See <see cref_property="PROPERTY_PMD_TRACE_IDENTIFIER"/></td>
          </tr>
          <tr>
            <td>AUTOGEN_VENDOR_DLL_TRACE_DLL_FILE_NAME</td>
            <td>If FastTrace does not recognise a chipset supplier ID / category ID combination then FastTrace will do one
                of two possible things depending upon whether AUTOGEN_VENDOR_DLL_TRACE_DLL_FILE_NAME is defined or not.<br/>
                If AUTOGEN_VENDOR_DLL_TRACE_DLL_FILE_NAME is defined then it specifies a default DLL to be called to decode
                the message. (See also AUTOGEN_VENDOR_DLL_TRACE_DLL_FUNCTION_NAME below)<br/>
                <br/>
                If AUTOGEN_VENDOR_DLL_TRACE_DLL_FILE_NAME is not defined then FastTrace will print out the message contents
                as hex values.<br/>
                <br/>
                (Note: AUTOGEN_VENDOR_DLL_TRACE_DLL_FILE_NAME is also used as vendor DLL name when AUTOGEN_USE_CHIPSET_SUPPLIER_DESCRIPTION is not defined.)</td>
          </tr>
          <tr>
            <td>AUTOGEN_VENDOR_DLL_TRACE_DLL_FUNCTION_NAME</td>
            <td>This is the vendor DLL function name to be called on the default DLL when it is called. 
                (See description in AUTOGEN_VENDOR_DLL_TRACE_DLL_FILE_NAME).<br/>
                <br/>
                (Note: AUTOGEN_VENDOR_DLL_TRACE_DLL_FUNCTION_NAME is also used as vendor DLL function name when AUTOGEN_USE_CHIPSET_SUPPLIER_DESCRIPTION is not defined.)</td>
          </tr>
        </table>
        The location of the various Chipset Supplier Descriptions must be specified in a file named autogen_vendor_includes.h.
        This file must contain an array containing the paths and filenames of the various Chipset Supplier Descriptions xml files
        to be loaded.<br/>
        <br/>
        Example: (autogen_vendor_includes.h)<br/>
        <pre>
            char *chipset_supplier_description_xml_files[] = {
                "chipset_supplier_description_1.xml",
                "chipset_supplier_description_2.xml",
                NULL /* Stop condition. Do not remove.. */
                };</pre>
        Note that the paths and filenames of the Chipset Supplier Description xml files are relative to current working directory 
        when executing autogen.<br/>
        Note that list of strings MUST be terminated by NULL.<br/>
        (Note that AUTOGEN_VENDOR_DLL_TRACE_GROUP_FILE_NAME must not be defined.)
      </summary>
    </section>
    <section name="Chipset Supplier ID allocations">
      <summary>
        The following table shows the unique chipset supplier identifiers that have been allocated to various chipset
        suppliers.<br/>
        <br/>
        <table border="0">
          <tr><th>Chipset supplier ID</th><th>Chipset supplier</th><th>Project</th><th>In use / Obsolete</th></tr>
          <tr><td>10</td><td>Infineon</td><td>Quantum</td><td>In use</td></tr>
          <tr><td>11</td><td>Infineon</td><td>Jakarta</td><td>In use</td></tr>
          <tr><td>12</td><td>Broadcom</td><td>Santiago</td><td>In use</td></tr>
          <tr><td>14</td><td>Wireless Modem Broadcom</td><td>Wireless Modem</td><td>Obsolete</td></tr>
          <tr><td>15</td><td>Wireless Modem STE</td><td>Wireless Modem</td><td>In use</td></tr>
          <tr><td>16</td><td>Texas Instruments</td><td>Wireless Modem</td><td>Obsolete</td></tr>
          <tr><td>17</td><td>Wireless Modem</td><td>Dalton</td><td>In use</td></tr>
          <tr><td>...</td><td>...</td><td>...</td><td>...</td></tr>
          <tr><td>100</td><td>Nokia</td><td>S40 NOS</td><td>In use</td></tr>
        </table>
        <br/>
        Each vendor must use their assigned value in their Chipset Supplier Descriptions. 
        The value is written in the XML attribute ChipsetSupplierId (see tag ChipsetSupplierDescription).<br/>
      </summary>
    </section>          
  </topic>
<!-- 
=======================================================================================
 Message items
======================================================================================= 
-->
  <topic name="Strings" group="Message items">
    <summary>
      Strings are message/trace items that represents ASCII characters
      (or other supported character coding schemes, such as UTF-8 or Unicode).
    </summary>
    <section name="Fixed length strings">
      <summary>
        The <see cref_macro="STRING"/> macro is used for defining strings of fixed length.
        <br/>
        This means that a fixed number of bytes in the message/trace is reserved for the text string.
        If the actual string is shorter than the reserved number of bytes, 0-paddings must be used.
        <br/>
        If these criterias are not met, the string is not a fixed length string,
        and the macro <see cref_macro="STRING_REF"/> should be used instead.
      </summary>
    </section>
    <section name="Variable length strings">
      <summary>
        The <see cref_macro="STRING_REF"/> macro is used for defining strings with variable lengths.
        <br/>
        The actual length of the string can be determined by a separate field (a reference),
        by presence of a 0-terminator or indirectly by the sub block/message length.
        <br/>
        Note that the string length for some string types are defined as number of bytes and
        for other string types as number of characters.
      </summary>
    </section>
  </topic>
  <topic name="Merging items" group="Message items">
    <summary>
      A merged item is a message item, composed of one or more individual message items.
      Order type of these message items must be the same as specified in MERGE_BEGIN.
      The only exceptions are 1-bit versions of pre-defined symbols such as YES_NO_1, TRUE_FALSE_1, etc. which are all BE.
      The size of the message items in bits within a merged item can be of any size less
      than the defined size of the merged field itself.
      <br/>
      The size of a merged item in bits must be 8, 16, 32, and 64 (when using PMD file format 6.00) see <see cref_topic="Using 64-bit macros"/>. 
      <br/><br/>
      Using merged items is the only possible way to define message items with a size
      different from 8, 16, 32, and bits.
      <br/><br/>
      Only a subset of the ISI message macros are allowed within a merged item.
      <br/><br/>
      Example of a merged field definition:
      <code filename="mergedfield_macro.txt"/>
      which generates the following in the ISI header file:
      <code filename="mergedfield_isihdr.txt"/>
    </summary>
    <seealso cref_macro="MERGE_BEGIN"/>
    <seealso cref_macro="MERGE_END"/>
  </topic>
  <topic name="Arrays" group="Message items">
    <summary>
      An array is simply a repetition of a sequence, see <see cref_topic="Sequences"/>.
      <br/>
      Basically, defining an array requires two informations; an array
      element and a number of elements in the array.
    </summary>
    <section name="Array elements">
      <summary>
        The array element must always be a sequence.
        However, as sequences are complex or simple (see <see cref_topic="Sequences"/>),
        so are the arrays.
        <br/>
        Defining an array with complex elements is only possible when:
        <ul>
          <li>
            The sequence is a structure (<b>CREATE_STRUCT</b> flag is defined for the sequence)
          </li>
        </ul>
        <br/>
        Note that for <see cref_topic="ISI resources"/>,
        the following rules are also applied for complex arrays
        (as this is analogue to sub block lists):
        <ul>
          <li>
            The sequence (defining the array element) must be divisible by 4 in length.
            If the number of elements is only one (fixed), this is not necessary.
          </li>
          <li>The array is defined at an 32 bit aligned address</li>
        </ul>
        <br/>
        Note also, that complex sequences can often be turned into simple
        sequences using the merge feature (see <see cref_topic="Merging items"/>),
        so the problems above can be avoided.
      </summary>
    </section>
    <section name="Number of elements in arrays">
      <summary>
        The number of elements in an array can be either fixed or dynamic.
        When the number of elements is dynamic,
        autogen supports three ways to define the actual number:
        <ul>
          <li>
            <b>Reference</b>. An element prior to the array definition must contain the number.
            This must be defined as a reference then. See <see cref_macro="REFERENCE"/>.
          </li>
          <li>
            <b>As Many As possible</b>. Indicates that the number of elements is
            indirectly determined by the lenth of the message/trace/sub block
          </li>
          <li>
            <b>Optional</b>. Indicates that the array contains zero or one element.
            This is a specialisation of <b>As Many As Possible</b>.
          </li>
        </ul>
        <br/>
        The macro <see cref_macro="SEQ_OF"/> defines an array with a fixed number of
        elements and the macro <see cref_macro="SEQ_OF_REF"/> defines an array with a
        dynamic number of elements.
      </summary>
    </section>
    <section name="Examples of arrays of simple sequences">
      <summary>
        The following example defines a simple array of bytes.
        The size of the array is fixed to 7:
        <code filename="arrays_simple_macro.txt"/>
        This is generated in the ISI header file:
        <code filename="arrays_simple_isihdr.txt"/>
        <br/>
        The next example defines a simple array of bytes. Now,
        the number of elements is dynamic, though limited to <b>MAX_ELEMENTS</b>:
        <code filename="arrays_simple_dyn_macro.txt"/>
        This is generated in the ISI header file:
        <code filename="arrays_simple_dyn_isihdr.txt"/>
      </summary>
    </section>
    <section name="Example of a complex array definition">
      <summary>
        The following example defines an array of structures with 3 elements:
        <code filename="arrays_complex_fix_macro.txt"/>
        This is generated in the ISI header file:
        <code filename="arrays_complex_fix_isihdr.txt"/>
      </summary>
    </section>
    <seealso cref_macro="SEQ_OF"/>
    <seealso cref_macro="SEQ_OF_REF"/>
  </topic>
  <topic name="Printf" group="Message items">
    <summary>
      Autogen offers a printf definition using <see cref_macro="PRINTF_BEGIN"/> and <see cref_macro="PRINTF_END"/>
      that is similar to the printf functionality in C. Currently the functionality is only supported for Symbian traces.<br/><br/>
      An example of a printf defintion is:
      <code filename="printf_def.txt"/>
      The PRINTF_BEGIN has a format string containing %s and %d as specifiers. The two embedded macros lists
      the arguments and their type. The type and number of the argument macros must match the specifiers used in the format
      string. See <see cref_macro="PRINTF_BEGIN"/> for further detail about allowed specifiers and argument macros.
    </summary>
    <section name="Printf functionality">
      <summary>
      The reason for having a printf functionality is to offer printf functionality without using a lot of bandwidth
      to transfer the text string from the phone. This is achived by storing the format string in the PMD file
      and only transfering an unique identifier for the format string and the optional arguments from the phone.
      The identifier consists of the following items:
      <ul>
        <li>Component ID (32 bits)</li>
        <li>Trace group ID (16 bits)</li>
        <li>Trace ID (16 bits)</li>
      </ul>
      FastTrace will be able to look up the format string in PMD file using this identifier and then apply the arguments
      from the trace.<br/>
      </summary>
    </section>
    <section name="Detailed example">
      <summary>
      A printf definition can only exists within a trace definition as shown in the following example.
      <code filename="printf_trace.txt"/>
      Trace group ID and trace ID is taken from the <see cref_macro="TRACE_GROUP_BEGIN"/> and <see cref_macro="TRACE_GROUP_BEGIN"/>.
      The component ID is specified in a property <see cref_property="PROPERTY_COMPONENT_ID"/>.<br/>
      This is the reason why only one printf definition can exist per trace.<br/>
      </summary>
    </section>
    <section name="Format string">
      <summary>
        See the <see cref_macro="PRINTF_BEGIN"/> macro for which specifiers are allowed and which macros that can be used
        to specify the arguments.
      </summary>
    </section>
    <section name="Fillers">
      <summary>
        It is possible to use <see cref_macro="FILLER"/> in the argument list, ie. between <see cref_macro="PRINTF_BEGIN"/> and
        <see cref_macro="PRINTF_END"/>. There should not be any % specifier to match the filler. See the following exampel:<br/>
        <code filename="printf_filler.txt"/>
      </summary>
    </section>
    <section name="Strings">
      <summary>
        Strings can either be fixed length strings using <see cref_macro="STRING"/> or variable length string using 
        <see cref_macro="STRING_REF"/>.<br/><br/>
        An example on a fixed length string:<br/>
        <code filename="printf_string_fixed.txt"/>
        <br/>
        Variable length strings normally uses a <see cref_macro="REFERENCE"/> to contain the length of the string.
        Currently it is not supported to place the <see cref_macro="REFERENCE"/> macro in the parameter list, ie
        between <see cref_macro="PRINTF_BEGIN"/> and <see cref_macro="PRINTF_END"/>. Instead it must be placed outside
        the parameter list.<br/><br/>
        A valid construction:<br/>
        <code filename="printf_string_variable_valid.txt"/>
        An invalid construction:<br/>
        <code filename="printf_string_variable_bad.txt"/>
      </summary>
    </section>    
    <section name="Properties">
      <summary>
        All parameters inside the <see cref_macro="PRINTF_BEGIN"/> / <see cref_macro="PRINTF_END"/> are normally
        not printed out in FastTrace PMD single line view. Only the format string with parameters substituted in
        is displayed. But by marking a parameter with the property <see cref_property="PROPERTY_PMD_PARAMETER"/>
        then the parameter field will be listed along with the format string (with parameters substituted in).<br/>
        <br/>
        <code filename="printf_property_pmd_paramter.txt"/>
      </summary>
    </section>
    <seealso cref_macro="PRINTF_BEGIN"/>
    <seealso cref_macro="PRINTF_END"/>
    <seealso cref_property="PROPERTY_COMPONENT_ID"/>
    <seealso cref_property="PROPERTY_PMD_PARAMETER"/>
    <seealso cref_property="PROPERTY_PMD_IS_NOT_PARAMETER"/>
  </topic>
  <!-- 
=======================================================================================
 Errorcodes
======================================================================================= 
-->
  <errorcode name="Error_1" group="Error codes">
    <summary>
      Warning: Argument 'parname' has leading blanks or underscores. Please remove!<br/>
      Warning: Argument 'parname' has trailing blanks or underscores. Please remove!
    </summary>
    <description>
      An example of a line causing this error could be<br/>
      <br/>
      <b>VALUE( 8, BE, nextfreqband, " Search current or next frequency band  ", DEC )</b><br/>
      <br/>
      Notice the leading and trailing spaces in the text in the 4. argument (parname).
    </description>
    <corrective>
      The reason for this warning is because these spaces can give problems in the XML output from Autogen
      (or the applications using the XML output). Currently autogen just removes any pre/postfix spaces 
      (and generates the above warning message), such that the generated XML looks like this:<br/>
      <br/>
      <b>... Name="Search current or next frequency band" ...</b><br/>
      <br/> 
      But this also means that there is a bit of difference between the text in the input macro file and 
      the output XML file.<br/>
      <br/>
      The fix is to remove all leading and trailing spaces from the text.
    </corrective>
  </errorcode>

  <errorcode name="Error_2" group="Error codes">
    <summary>
      Warning: Argument 'parname' contains invalid characters
    </summary>
    <description>
      An example of a line causing this error could be<br/>
      <br/>
      <b>VALUE( 8, BE, rt_content_type, "RT+ class id 0 to 63", DEC )</b><br/>
      <br/>
      Notice the + character in the 4. argument (parname).
    </description>
    <corrective>
      Only the following characters are allowed in the 'parname' argument:<br/>
      <br/>
      <b>'a' - 'z', 'A' - 'Z', '0' - '9', '_' and ' '</b> (space characters)
    </corrective>
  </errorcode>

  <errorcode name="Error_3" group="Error codes">
    <summary>
      Warning: Length of Subblock 'RADIO_TX_HW_INFO_SB' is potentionally 260 bytes, which is larger than the maximum allowed length of 252 bytes
    </summary>
    <description>
      An example of a piece of code generating this warning could be:<br/>
      <pre>
      SB_BEGIN(RADIO_TX_HW_INFO_SB,"","")
          RADIO_COMMON_SB
          COMMENT(COMMENT_TEXT,"Vendor HW info string")
          REFERENCE(8, BE, length_of_string, "Length of hwString", M)
          STRING_REF(STRING_ASCII, BE, hwString, "Hw String", M, ISIHDR_MARKER_ANYSIZE)
          FILLER(FILLER_VARIABLE, 32)
      SB_END
      </pre>
      Here it is important to note that <b>RADIO_COMMON_SB</b> is defined as follows:<br/>
      <pre>
      #define RADIO_COMMON_SB \
          REFERENCE(8, BE, sub_block_id, "Sub Block ID", SB_ID) \
          REFERENCE(8, BE, sub_block_length, "Sub Block Length", SB_LENGTH) \
      </pre>
      Notice that the subblock length is an 8 bit field.
    </description>
    <corrective>
      The reason for the warning is because the 8 bit REFERENCE in the subblock is not restricted in size. 
      This means that the string can possibly contain up to 256 characters. And since the subblock length field
      is only 8 bits there is a potential problem here which Autogen warns about.<br/>
      <br/>
      To restrict the size of the REFERENCE value ('M') you can use the property <b>PROPERTY_ITEM_MAXIMUM_VALUE</b>. 
      Please see the example below and the text in bold.<br/>
      <pre>
      SB_BEGIN(RADIO_TX_HW_INFO_SB,"","")
          RADIO_COMMON_SB
          COMMENT(COMMENT_TEXT,"Vendor HW info string")
          <b>PROPERTY_VALUE(PROPERTY_ITEM_MAXIMUM_VALUE, 240)</b>
          REFERENCE(8, BE, length_of_string, "Length of hwString", M)
          STRING_REF(STRING_ASCII, BE, hwString, "Hw String", M, ISIHDR_MARKER_ANYSIZE)
          FILLER(FILLER_VARIABLE, 32)
      SB_END
      </pre>
      The value of the property should be the max allowed size of the REFERENCE value ('M').<br/>
      <br/>
      Just for reference then the opposite property also exists <b>PROPERTY_ITEM_MINIMUM_VALUE</b>.<br/>
      <br/>
      More documentation can be found here about the properties <see cref_property="PROPERTY_ITEM_MAXIMUM_VALUE" /> 
      and <see cref_property="PROPERTY_ITEM_MINIMUM_VALUE" />. The <see cref_macro="REFERENCE" /> macro is 
      described here.
    </corrective>
  </errorcode>
  
  <errorcode name="Error_4" group="Error codes">
    <summary>
      Warning: Possibly incompatible changes made, but version indicates compatible changes!
    </summary>
    <description>
      The following code example shows a case where this warning will be generated:<br/>
      <pre>
        SEQ_BEGIN(MY_SEQ, CREATE_STRUCT, "000.000", "001.005" ) 
            VALUE_CONST(stateA, "StateA", YES_NO)
            VALUE_CONST(stateB, "StateB", YES_NO)
        SEQ_END

        SEQ_BEGIN(MY_SEQ, CREATE_STRUCT, "001.005", "" ) 
            VALUE_CONST(stateA, "StateA", YES_NO)
        SEQ_END

        MSG_BEGIN(MY_REQ, MESSAGE_REQ, "000.005", "" )
            COMMON_MSG_HDR
            FILLER(FILLER_FIXED, 16)
            SEQ_OF(MY_SEQ, "My structure", MY_SEQ, 1)
        MSG_END
      </pre>
      When running this autogen will generate the following output:<br/>
      <pre>
        ISI version 000.005:
        ISI version 001.005:
        Warning: Possibly incompatible changes made, but version indicates compatible changes!
      </pre>
      The reason is that the VALUE_CONST containing StateB has been removed from the sequence valid from version 001.005. 
      This change is not backward compatible. It will therefor require a major version number change. In this case there has only
      been a minor version change to 0001.005
    </description>
    <corrective>
      Autogen warns when it detects that changes have been made that is not backwards compatible and this has not
      been marked with a major version change.<br/>
      A number of things to be aware of:<br/><br/>
      <ul>
        <li>Removing items is not backward compatible and requires a major version change. <br/>
            Note that adding new items is backward compatible and therefor only requires a minor version change.</li>
        <li>Be aware of renumbering. E.g. there is a hole in the numbers here.<br/>
        <pre>
          #define XXX_DEMO_A                          0x00
          #define XXX_DEMO_B                          0x02
          #define XXX_DEMO_C                          0x03
        </pre>
        It might be tempting to renumber to 0x00 -> 0x02 but this is not backward compatible.</li>
      </ul>
    </corrective>
  </errorcode>
  
  <errorcode name="Error_5" group="Error codes">
    <summary>
      Warning: Re-introduced Sequence MY_SEQ. Gap before version 001.006 detected
    </summary>
    <description>
      The following code example will generate the above warning message.
      <pre>      
        SEQ_BEGIN(MY_SEQ, CREATE_STRUCT, "000.000", "001.005" ) 
            VALUE_CONST(stateA, "StateA", YES_NO)
        SEQ_END

        SEQ_BEGIN(MY_SEQ, CREATE_STRUCT, "001.006", "" ) 
            VALUE_CONST(stateA, "StateA", YES_NO)
            VALUE_CONST(stateB, "StateB", YES_NO)
        SEQ_END

        MSG_BEGIN(MY_REQ, MESSAGE_REQ, "001.006", "" )
            COMMON_MSG_HDR
            FILLER(FILLER_FIXED, 16)
            SEQ_OF(MY_SEQ, "My structure", MY_SEQ, 1)
        MSG_END       
      </pre>
      The output from autogen will look like this:<br/>
      <pre>
        ISI version 001.005:
        ISI version 001.006:
        Warning: Re-introduced Sequence MY_SEQ. Gap before version 001.006 detected
      </pre>
      The problem here is there is a gab in the half open interval [1.5; 1.6[. The writer has probably thought that
      the first sequence should be valid up till (and including) version 1.5. The next sequence should then be valid 
      there after.
    </description>
    <corrective>
      Autogen allows one to specify an interval (from, to) within which a given construct is valid. 
      This interval is an half open interval, i.e. [from; to[.<br/><br/>
      E.g. 
      <pre>
        CONSTANT_VER("My const", MY_CONST, "001.000", "001.005")
      </pre>
      This constant will not be valid for version 1.5.<br/><br/>
      The correct way to write the above code piece would be:<br/>
      <pre>
        SEQ_BEGIN(MY_SEQ, CREATE_STRUCT, "000.000", "001.005" ) 
            ...

        SEQ_BEGIN(MY_SEQ, CREATE_STRUCT, "001.005", "" ) 
            ...
      </pre>
    </corrective>
  </errorcode>

  <errorcode name="Error_6" group="Error codes">
    <summary>
      Warning: Compatible changes made, but version indicates incompatible changes!
    </summary>
    <description>
      The above warning message will be generated by the following code:<br/>
      <pre>
        SEQ_BEGIN(MY_SEQ_A, CREATE_STRUCT, "000.005", "" ) 
             VALUE_CONST(stateA, "StateA", ON_OFF_16)
        SEQ_END
     
        SEQ_BEGIN(MY_SEQ_B, CREATE_STRUCT, "001.000", "" ) 
             VALUE_CONST(stateB, "StateB", ON_OFF_16)
        SEQ_END
     
        MSG_BEGIN(MY_REQ_1, MESSAGE_REQ, "001.000", "" )
             COMMON_MSG_HDR
             FILLER(FILLER_FIXED, 16)
             SEQ_OF(MY_SEQ_A, "My structure A", MY_SEQ_A, 1)
             FILLER(FILLER_FIXED, 16)
             SEQ_OF(MY_SEQ_B, "My structure B", MY_SEQ_B, 1)
        MSG_END       
      </pre>
      The reason for the warning is the addition of the sequence MY_SEQ_B. But addition of new objects
      does not require updating the major version number, only updating the minor version number.
      In this case the MY_SEQ_B indicates a major version number change.
    </description>
    <corrective>
      This is a warning that a major version number change is not necessary and a minor version number change
      may suffice. 
    </corrective>
  </errorcode>

  <errorcode name="Error_7" group="Error codes">
    <summary>
      Warning: Length of Subblock 'MY_SB' is not divisible by 4<br/>
      Warning: The Sequence 'MY_SEQ' is inserted several times, but doesn't have a length divisible by 4<br/><br/>
      Warning: In Message 'MY_REQ', the 16 bit dynamic filler can be replaced by an 8 bit fixed filler<br/>
      Warning: In Message 'MY_REQ', the 24 bit dynamic filler can be replaced by an 8 bit fixed filler<br/>
      Warning: In Message 'MY_REQ', the 24 bit dynamic filler can be replaced by a 16 bit fixed filler<br/>
      Warning: In Message 'MY_REQ', the 24 bit dynamic filler can be replaced by a 24 bit fixed filler<br/>
      Warning: In Subblock 'MY_SB', the 32 bit dynamic filler can be replaced by an 8 bit fixed filler<br/>
      Warning: In Subblock 'MY_SB', the 32 bit dynamic filler can be replaced by a 16 bit fixed filler<br/>
      Warning: In Subblock 'MY_SB', the 32 bit dynamic filler can be replaced by a 24 bit fixed filler<br/><br/>
      INFO: In Message 'MY_REQ', the 16 bit dynamic filler is not needed<br/>
      INFO: In Message 'MY_REQ', the 32 bit dynamic filler is not needed<br/><br/>
      Warning: Alignment problem in Message 'MY_REQ'. A dynamic 16 bit alignment must be inserted<br/>
      Warning: Alignment problem in Message 'MY_REQ'. A dynamic 32 bit alignment is needed<br/><br/>
      Warning: Alignment problem in Message 'MY_REQ'. A fixed 8 bit alignment must be inserted<br/>
      Warning: Alignment problem in Message 'MY_REQ'. A fixed 16 bit alignment must be inserted<br/>
      Warning: Alignment problem in Message 'MY_REQ'. A fixed 24 bit alignment must be inserted
    </summary>
    <description>
      All the above warnings cover various aspects of the alignment rules for constructing ISA messages and traces.<br/>
      A piece of macro code generating one of the above errors could be:<br/>
      <pre>
        SB_BEGIN(MY_SB, "", "")
            COMMON_SB
            VALUE_CONST(RESET, "Reset", YES_NO)
            STRING(STRING_ASCII, BE, reason, "Reason", 8)
        SB_END      
      </pre>
      This will generate the error:<br/>
      <pre>
        Warning: Length of Subblock 'MY_SB' is not divisible by 4
      </pre>
      The COMMON_SB header is 2 bytes, the VALUE_CONST is 1 byte and the string is 8 bytes. This is totally 11 bytes
      and therefor not divisible by 4 which is an ISA requirement.
    </description>
    <corrective>
      The interface between the microprocessor and the memory is designed differently from processor to processor. 
      This puts restrictions on the positioning of the data items on some processors<br/>
      <br/>
      To summarize:<br/>
      <ul>
        <li>The ARM requires 32-bit on 4-byte boundaries</li>
        <li>The Intel x86 family allow 32-bit items anywhere</li>
      </ul>
      <br/>
      <ul>
        <li>The ARM requires 16-bit on 2-byte boundaries</li>
        <li>The Intel x86 family allow 16-bit items anywhere</li>
      </ul>
      <br/>
      By declaring structures in such a way that there will be no implicit padding on the most restrictive processor
      architectures, binary compatibility can be ensured. This of course does not address the issue of endianess<br/>
      <br/> 
      ISI message definitions use the following rules for the layout of messages
      <ul>
        <li>1-byte items may be freely placed</li>
        <li>2-byte items should start at even addresses</li>
        <li>4-byte items should start at addresses divisible by 4</li>
        <li>Sub blocks should start at addresses divisible by 4</li>
      </ul>
      <br/>
      <b>How does autogen support this?</b><br/>
      When constructing new messages or traces then one can try to order the various parts of the message or trace
      such that the alignment requirements are fullfilled. If this is not enough then autogen supports a filler macro.
      Please see <see cref_macro="FILLER"/>. This macro comes in two different forms.<br/>
      <ul>
        <li>FILLER(FILLER_FIXED, length)</li>
        <li>FILLER(FILLER_VARIABLE, length)</li>
      </ul>
      <br/>
      The FIXED filler variant is used when a fixed size filler is needed to fulfill the alignment rules.<br/>
      An example:
      <pre>
        SB_BEGIN(MY_SB, "", "")
             COMMON_SB
             VALUE_CONST(RESET, "Reset", YES_NO)
             VALUE(32, BE, value, "Value", DEC)
        SB_END      
      </pre>
      This will produce the following two warnings from autogen.
      <pre>
        Warning: Alignment problem in Subblock 'MY_SB'. A fixed 8 bit alignment must be inserted
        Warning: Length of Subblock 'MY_SB' is not divisible by 4 
      </pre>
      The COMMON_SB has a size of 2 bytes, the VALUE_CONST is 1 byte and the VALUE is 4 bytes.<br/>
      The first problem is that the VALUE does not start on an address divisible with 4. The suggestion from
      autogen is to insert a fixed 8 bit filler (after the VALUE_CONST). The second problem is that the size of the subblock is 7 bytes
      and therefor not divisible by 4. Inserting the 8 bit fixed filler will also solve this problem.<br/><br/>
      The result is:
      <pre>
        SB_BEGIN(MY_SB, "", "")
             COMMON_SB
             VALUE_CONST(RESET, "Reset", YES_NO)
             FILLER(FILLER_FIXED, 8)
             VALUE(32, BE, value, "Value", DEC)
        SB_END              
      </pre>
      The VARIABLE filler is useful when alignment must be ensured after a variable length item.<br/><br/>
      An example could be:
      <pre>
        SB_BEGIN(MY_SB, "", "")
             COMMON_SB
             PROPERTY_VALUE(PROPERTY_ITEM_MAXIMUM_VALUE, 8)
             REFERENCE(8, BE, size, "Size", N)
             STRING_REF(STRING_ASCII, BE, reason, "Reason", N, ISIHDR_RESERVE_SPACE)
        SB_END      
      </pre>
      This generates the following warning:
      <pre>
        Warning: Length of Subblock 'MY_SB' is not divisible by 4
      </pre>
      The reason is that the subblock length must be divisible by 4 but here we have a variable length string.
      So we need to put in a varible number of filler bytes such that the length becomes divisible by 4.
      This can be specified in the macro language using the FILLER_VARIABLE variant. The solution becomes:<br/>
      <pre>
        SB_BEGIN(MY_SB, "", "")
             COMMON_SB
             PROPERTY_VALUE(PROPERTY_ITEM_MAXIMUM_VALUE, 8)
             REFERENCE(8, BE, size, "Size", N)
             STRING_REF(STRING_ASCII, BE, reason, "Reason", N, ISIHDR_RESERVE_SPACE)
             FILLER(FILLER_VARIABLE, 32)
        SB_END      
      </pre>
      Here the filler serves as a variable size filler between 1 and 4 bytes to ensure that the subblock length is
      divisible by 4.
    </corrective>
  </errorcode>
  
  <errorcode name="Error_8" group="Error codes">
    <summary>
      Warning: Subblock already defined using the same ID. Subblocks: MY_SB_A - MY_SB_B
    </summary>
    <description>
      All subblocks are assigned an Id which should be unique. If this is not the case then the above error message is generated.
      An example of a faulty construction:
      <pre>
        ...
        /* Sub block ID's */
        <b>#define MY_SB_A  0x01
        #define MY_SB_B  0x01</b>
        ...

        SB_BEGIN(<b>MY_SB_A</b>, "", "")
             COMMON_SB
             VALUE(16, BE, var1, "Variable 1", DEC)
        SB_END      
     
       SB_BEGIN(<b>MY_SB_B</b>, "", "")
             COMMON_SB
             VALUE(16, BE, var2, "Variable 2", HEX)
        SB_END      
     
        MSG_BEGIN(MY_REQ_A, MESSAGE_REQ, "", "" )
             COMMON_MSG_HDR
             FILLER(FILLER_FIXED, 16)
             SB_LST_BEGIN(LIST_OF_SUBBLOCKS, sub_blocks, "Sub blocks", 4, ISIHDR_MARKER_ANYSIZE)
                 SB_LST_ENTRY(MY_SB_A)
             SB_LST_REF_END
        MSG_END       
     
        MSG_BEGIN(MY_REQ_B, MESSAGE_REQ, "", "" )
             COMMON_MSG_HDR
             FILLER(FILLER_FIXED, 16)
             SB_LST_BEGIN(LIST_OF_SUBBLOCKS, sub_blocks, "Sub blocks", 2, ISIHDR_MARKER_ANYSIZE)
                 SB_LST_ENTRY(MY_SB_B)
             SB_LST_REF_END
        MSG_END       
        ...        
      </pre>
      The two subblock IDs, MY_SB_A and MY_SB_B, have both the same value, ie. 0x01. This generates the above error message.
    </description>
    <corrective>
      Ensure that all subblocks are given unique Id values.
    </corrective>
  </errorcode>
  
  <errorcode name="Error_9" group="Error codes">
    <summary>
      Warning: All referenced subblock IDs must be unique within subblock list.
    </summary>
    <description>
      All subblocks used within a subblock list must have unique IDs. Otherwise the above error message is generated.
      An example of a faulty construction
      <pre>
        ...        
        /* Sub block ID's */
        <b>#define MY_SB_A  0x01  
        #define MY_SB_B  0x01</b>  
        ...

       SB_BEGIN(MY_SB_A, "", "")
            COMMON_SB
            VALUE(16, BE, var1, "Variable 1", DEC)
       SB_END      
     
       SB_BEGIN(MY_SB_B, "", "")
             COMMON_SB
             VALUE(16, BE, var2, "Variable 2", HEX)
        SB_END      
     
        MSG_BEGIN(MY_REQ, MESSAGE_REQ, "", "" )
             COMMON_MSG_HDR
             FILLER(FILLER_FIXED, 16)
             SB_LST_BEGIN(LIST_OF_SUBBLOCKS, sub_blocks, "Sub blocks", 4, ISIHDR_MARKER_ANYSIZE)
                 <b>SB_LST_ENTRY(MY_SB_A)  
                 SB_LST_ENTRY(MY_SB_B)</b>  
             SB_LST_REF_END
        MSG_END       
      </pre>
      The error will refer to the macro <b>SB_LST_ENTRY(MY_SB_B)</b> where autogen sees the same ID again in the
      SB_LST_BEGIN().
    </description>
    <corrective>
      Ensure that all subblocks are given unique Id values.
    </corrective>
  </errorcode>

  <errorcode name="Error_10" group="Error codes">
    <summary>
      Warning: The response message 'MY_RESP' doesn't exist for all required versions
    </summary>
    <description>
      When defining a MSG_PAIR then the response message must exist in an version interval overlapping the version interval of
      the request message. An example where this is not the case.
      <pre>
        MSG_BEGIN(MY_REQ, MESSAGE_REQ, "000.005", "" )
             COMMON_MSG_HDR
        MSG_END       
     
        MSG_BEGIN(MY_RESP, MESSAGE_RESP, "000.008", "" )
             COMMON_MSG_HDR
             VALUE(16, BE, resp_val, "Response value", HEX)
        MSG_END       
     
        MSG_PAIR(MY_REQ, MY_RESP)
      </pre>
      The request message is defined from version 0.5 and onwards, but the response message is only defined from 
      version 0.8 and onwards. This generates the above error message.
    </description>
    <corrective>
      It must be ensured that the version interval of the response message covers the version interval of the request message.<br/>
      Note that the response message can easily be distributed over several version intervals and the combined intervals can be 
      bigger than the combined intervals of the request message. An example would be:
      <pre>
        MSG_BEGIN(MY_REQ, MESSAGE_REQ, "000.005", "" )
             COMMON_MSG_HDR
        MSG_END       

        MSG_BEGIN(MY_RESP, MESSAGE_RESP, "000.003", "000.008" )
             COMMON_MSG_HDR
             VALUE(16, BE, resp_val, "Response value", DEC)
        MSG_END       

        MSG_BEGIN(MY_RESP, MESSAGE_RESP, "000.008", "" )
             COMMON_MSG_HDR
             VALUE(16, BE, resp_val, "Response value", HEX)
        MSG_END       
     
        MSG_PAIR(MY_REQ, MY_RESP)
      </pre>
      The combined version interval of the response message is from 0.3 and onwards while the request message is from version
      0.5 and onwards.
    </corrective>
  </errorcode>

  <errorcode name="Error_11" group="Error codes">
    <summary>
      The file format version (0500) of the embedded PMD file (embedded.pmd) is not compatible in Tracing SDK with the file format version (0600) of this PMD file. (embedded.pmd) has been REMOVED!
    </summary>
    <description>
      Please see description in section (Compatibility between PMD files) in <see cref_subtopic="PMD files"/> for further description.
    </description>
    <corrective>
      The best and most safe procedure is to ensure that the PMD file and all embedded PMD files all are generated to have the 
      same PMD file format version. Otherwise ensure that all the embedded PMD files are compatible with the main PMD file.<br/>
      <br/>
      The PMD file format version is controlled via the flag <b>PMD_FILE_FORMAT</b> in configuration file <b>autogen_conf.h</b><br/>
      <br/>
      The following page (<a href="http://rdsuite/Default.aspx?wiki_2_page=pmd_guides" class="cref link">PMD File Format Compatibility</a>) 
      describes the various PMD file format versions and which ones that are compatible.
    </corrective>
  </errorcode>

<!-- Template for new error message descriptions  
  <errorcode name="Error_999" group="Error codes">
    <summary>
      To be written.
    </summary>
    <description>
      To be written.
    </description>
    <corrective>
      To be written.
    </corrective>
  </errorcode>
-->
  <!-- 
=======================================================================================
 Templates
======================================================================================= 
-->
  <example name="Template file for ISI resources" group="Templates">
    <summary>
      This template <b>template_isi_m.h</b> can be used as base for defining a message macro file for
      <see cref_topic="ISI resources"/> or other message based resources.
      <br/>
      <code filename="template_isi_m.h"/>
    </summary>
  </example>
  <example name="Template file for private ISI resources" group="Templates">
    <summary>
      This template <b>template_isi_priv_m.h</b> can be used as base for defining a message macro file for
      <see cref_topic="ISI private resources"/>.
      <br/>
      <code filename="template_isi_priv_m.h"/>
    </summary>
  </example>
  <example name="Template file for prefix ISI resources" group="Templates">
    <summary>
      This template <b>template_isi_prefix_m.h</b> can be used as base for defining a message macro file for
      <see cref_topic="ISI prefix resources"/>.
      <br/>
      <code filename="template_isi_prefix_m.h"/>
    </summary>
  </example>
  <example name="Template file for shared resources" group="Templates">
    <summary>
      This template <b>template_isi_shared_m.h</b> can be used as base for defining a message macro file for
      <see cref_topic="Shared resources"/>.
      <br/>
      <code filename="template_isi_shared_m.h"/>
    </summary>
  </example>
  <example name="Template file for MCU traces" group="Templates">
    <summary>
      This template <b>template_mon.ti</b> can be used as base for defining a message macro file for
      <see cref_topic="MCU traces"/>.
      <br/>
      <code filename="template_mon.ti"/>
    </summary>
  </example>
  <example name="Template file for invariant traces" group="Templates">
    <summary>
      This template <b>template_invariant_trace_m.h</b> can be used as base for defining a message macro file for
      <see cref_topic="Invariant traces"/>.
      <br/>
      <code filename="template_invariant_trace_m.h"/>
    </summary>
  </example>
<!--
=======================================================================================
 autogen tutorial
======================================================================================= 
-->
  <topic name="Introduction" group="Tutorial">
    <summary>
      The purpose of this tutorial is to give an introduction to autogen, to give solutions on how to solve
      various problems through use of examples and give pointers to where further information can be found in
      the autogen online reference documentation.<br/>
      <br/>
      Note that this tutorial is work in progress and therefor pages may be encountered that has not yet been finished.
    </summary>
    <section name="Content">
      <summary>
        The tutorial covers the following main sections:<br/>
        <table>
          <tr>
            <td><see cref_topic="Introduction"/></td>
            <td>This page.</td>
          </tr>
          <tr>
            <td><see cref_topic="Context"/></td>
            <td>This section gives an overview of autogen and how it fits into the context where it is used.</td>
          </tr>
          <tr>
            <td><see cref_topic="Autogen"/></td>
            <td>This section describes autogen in further detail.</td>
          </tr>
          <tr>
            <td><see cref_topic="Creating a macro file"/></td>
            <td>The section will give a few simple examples on how to make a macro file and how to make use of it.</td>
          </tr>
          <tr>
            <td><see cref_topic="Macro language"/></td>
            <td>This section goes into more details on how to make use of various macro language constructs.</td>
          </tr>
          <tr>
            <td><see cref_topic="Frequently Asked Questions"/></td>
            <td>Contains various frequently asked questions divided into a number of main categories.</td>
          </tr>
        </table>
      </summary>
    </section>
    <section name="Further documentation">
      <summary>
        Autogen is just one tool among several in the RD Suite of tools.<br/>
        <br/>
        The following table will list a number of places where further documentation may be found about the RD Suite of
        tools and specifically links to further documentation about autogen and FastTrace.<br/>
        <br/>
        <table>
          <tr>
            <td><a href="http://rdsuite.europe.nokia.com/">RD Suite homepage</a></td>
            <td>This is main entrance to the RD Suite of tools.</td>
          </tr>
          <tr>
            <td><a href="http://rdsuite.europe.nokia.com/products.asp">RD Suite Products</a></td>
            <td>This lists all the products part of RD Suite including autogen and FastTrace.</td>
          </tr>
          <tr>
            <td><a href="http://rdsuite.europe.nokia.com/products/autogen/overview.asp">Autogen homepage</a></td>
            <td>The entrypoint to the autogen homepage.</td>
          </tr>
          <tr>
            <td><a href="http://rdsuite.europe.nokia.com/products/fasttrace/overview.asp">FastTrace homepage</a></td>
            <td>The entrypoint to the FastTrace homepage.</td>
          </tr>
          <tr>
            <td><a href="http://www2.connecting.nokia.com/nmp/tmp/isatech.nsf/document/ES346QG9KS?OpenDocument">ISI Guidelines</a></td>
            <td>Various guidelines for writing ISI software.</td>
          </tr>
          <tr>
            <td><a href="http://www2.connecting.nokia.com/nmp/tmp/isatech.nsf/vwSearchIndex/7f8319a9a5841281c2257348002aad61?OpenDocument">Software Developer Alerts</a></td>
            <td>Software Developer Alerts</td>
          </tr>
        </table>
      </summary>
    </section>
  </topic>
  <topic name="Context" group="Tutorial">
    <summary>
      This section will give an overview of autogen and how this application works in conjunction with other
      applications like FastTrace.
    </summary>
    <section name="Purpose of autogen">
      <summary>
        Autogen is a command line tool that exists to support the developers of phone builds in two aspects:<br/>
        <ul>
          <li>Tracing</li>
          <li>ISA server message interface description</li>
        </ul>
        <br/>
        The following sections will describe more in detail in what respect autogen can support the developers.
      </summary>
    </section>
    <section name="Tracing">
      <summary>
        Mobile phones contain complex software and it is therefor necessary with a good tracing solution
        to track the execution of a program.<br/>
        As embedded systems like a mobile phone has limited processing power, limited communication bandwidth
        to the outside this will impact the tracing and impact the system it self. Too much tracing will 
        leave less processing power to the actual software processes that are being monitored. Therefore is 
        efficiency in this area an important aspect.<br/>
        As a text string can be quite verbose to trace, the approach to make the tracing more efficient 
        is to binary encode the trace data.<br/>
        <br/>
        An example on a binary trace is:<br/>
        <pre>
        80,1b,00,d0,b7,68,eb,46,1e,69,ac,00,4c,00,0f
        </pre>
        This trace data must be transferred from the mobile phone to a tracing application typically running 
        on a PC where the tracing information can be presented to the user. This tracing application in FastTrace.<br/>
        The following is examples on how FastTrace decodes the above binary trace.<br/>
        <br/>
        <b>Compact view:</b>
        <pre>
        12:19:45.281 os:  HOOK_SCHEDULE; old:OS_IDLE_TASK; new:MM_TASK
        </pre>
        <b>Detailed view:</b>
        <pre>
            ...
         9  (8) Group ID....................: 0x80       => NOS_TRACES
        10  (8) Trace ID....................: 0x1B       => HOOK_SCHEDULE
        11  (8) Filler......................: 0x00       => 8 bit padding
        12 (64) Time........................: ...61E69AC => 12:19:45.047898540
        20 (16) Old.........................: 0x004C     => OS_IDLE_TASK
        22 (16) New.........................: 0x000F     => MM_TASK
        </pre>
        As can be see then a 15 byte trace message can be decoded to a lot larger message presented to the user.<br/>
        <br/>
        To decode the above binary trace FastTrace must know how to map between the binary IDs and the corresponding
        text shown in the FastTrace UI. FastTrace gets this information from the PMD (Product Message Description) file.
        This file contains information on how to decode all binary traces from a specific version of a phone build.<br/>
        <br/>
        This PMD file is generated by autogen. Autogen supports a macro language that enables the user to specify
        how traces should be formatted. Using macro files as input enables autogen to produce a PMD file containing
        the description of how to decode traces that matches the traces specified in the macro files.<br/>
        An example of a macro expression that defines the tracedecoding for the above binary trace:
        <pre>
          /* HOOK_SCHEDULE */
          COMMENT(COMMENT_PARAGRAPH, "OS internal function hook")
          COMMENT(COMMENT_PARAGRAPH,
              "This message is output from os_schedule immediately before the "
              "call to os_task_switch.")
          TRACE_BEGIN(HOOK_SCHEDULE, "HOOK_SCHEDULE")
              VALUE_CONST( Old, "Old", OS_TASK_NAME )
              VALUE_CONST( New, "New", OS_TASK_NAME )
          TRACE_END()
        </pre>
        <b>Binary traces</b><br/>
        Binary traces consist basically of a fixed part present in all traces and an optionally part consisting of 
        variable data relevant for this specific trace.<br/>
        Looking at the 'Detailed view' above the fixed part consist of the following items:
        <ul>
          <li>Group ID</li>
          <li>Trace ID</li>
          <li>Filler</li>
          <li>Time</li>
        </ul>
        The first two items, Group ID and Trace ID, combined is a unique trace identifier. By dividing the trace identifier
        in two several traces belonging together can be grouped together. The Time part gives the time of the trace and 
        the Filler is to ensure that the Time item starts at a 4 byte boundary.<br/>
        Note that the above trace message is prefixed with some additional bytes which is the carrier protocol. This is
        not shown here.<br/>
        The items Old and New are the optional part that is specific for this trace (Group = 0x80 and Trace = 0x1B).
      </summary>
    </section>
    <section name="ISA server message interface description">
      <summary>
        ISA servers in the ISA MCU SW architecture all defines a message interface to communicate with each other.
        The structure and layout of these ISI messages must be defined and documented. Further more must C structures
        be defined to support the developer in constructing the messages in the code.<br/>
        To ensure that these stay in-sync with each others, it would be nice if the message interface is defined one place
        and documentation and C headers are automatically generated from this one source.<br/>
        Using the above mentioned macro language autogen supports this approach. All ISI messages are defined using the
        macro language. Using this as input autogen:
        <ul>
          <li>Generates HTML documentation</li>
          <li>Generates C header files for use in the ISA servers and applications</li>
          <li>Generates XML for other applications to use</li>
          <li>Validates the ISI messages and ensures that they are well constructed</li> 
        </ul>
        <br/>
        An example of an ISI messages:
        <pre>
          PROPERTY_STRING(PROPERTY_ISIHDR_STRUCT_LENGTH_NAME, "")
          MSG_BEGIN(PERM_PM_AMOUNT_QUERY_REQ, MESSAGE_REQ, "", "")
              PERM_MSG_HDR(PERM_PM_AMOUNT_QUERY_REQ_STR)
              PROPERTY(PROPERTY_PMD_PARAMETER)
              VALUE(16, BE, group_id, "Group ID", HEX)
          MSG_END
        </pre>        
      </summary>
    </section>
  </topic>
  <subtopic name="Drawing of autogen setup" topic="Context">
    <summary>
      The following drawing shows where autogen fits in.<br/><br/>
      <img src="pics/tut_overview.png"/><br/><br/>
    </summary>
    <section name="Mobile phone">
      <summary>
        The mobile phone shows a device under test. It contains software with tracing enabled. The picture
        shows various software components sending out trace messages through the Monitor Server. 
      </summary>
    </section>
    <section name="Tracing PC with FastTrace installed">
      <summary>
        The PC is running FastTrace which is an application that collects trace data sent out from a mobile phone.
        The received trace data is decoded using the decoding description in a PMD file. The decoded traces are
        presented to the user in a easy and readable format.
      </summary>
    </section>
    <section name="Musti box">
      <summary>
        An interface box collecting the traces from the mobile phone and passing them on to the PC running 
        FastTrace.
      </summary>
    </section>
    <section name="Phone build">
      <summary>
        This represents the whole software hierarchy and build environment of a phone software build.
        Autogen is normally integrated into the build environment like the macro file input to autogen is also 
        normally part of the software hierarchy. When the phone software is build, autogen will normally be
        executed as part of the build.<br/>
      </summary>
    </section>
    <section name="autogen">
      <summary>
        This represents autogen, the input macro files and the various output files generated. The input macro files
        contain either trace statement definitions or ISI message definitions for the ISA server interfaces. The various
        input and output files will described in more detail later but a short summary of their purpose is:
        <table border="0">
          <tr>
            <td>Macro files</td>        <td>Input files containing trace or ISI message definitions.</td>
          </tr><tr>
            <td>ISI Header files</td>   <td>Output files containing C header structures corresponding to the contents
                                            of the input macro files. These can be used in the phone build to support
                                            the creation of ISI messages.</td>
          </tr><tr>
            <td>HTML files</td>         <td>Output files useful for documenting the ISI messages defined in the macro
                                            files.</td>
          </tr><tr>
            <td>XML files</td>          <td>Output files containing a representation of contents of the macro files 
                                            just in XML. These files can then be used by other applications.</td>
          </tr><tr>
            <td>TSA files</td>          <td>Output files containing C++ classes based on the input macro files.</td>
          </tr><tr>
            <td>PMD files</td>          <td>Output files used for decoding binary traces received in FastTrace from
                                            a phone under test.</td>
          </tr>
        </table>
      </summary>
    </section>
  </subtopic>    
  <topic name="Autogen" group="Tutorial">
    <summary>
      This section goes into more details about autogen, the output generated, how to configure autogen and how 
      to execute autogen.
    </summary>
    <section name="Overview">
      <summary>
        Autogen works by inputting macro language files defining ISI messages and / or trace definitions. From this input
        various output files are generated: ISI headers, HTML, XML, TSA, PMD.<br/>
        <br/>
        Before generating the output files autogen will run various validation and consistency checks on the input 
        macro files.<br/>
        <br/>
        When autogen is executed it can run in one of several modes. The actual mode that autogen will execute in
        depends on a compile time flag, defined when autogen is compiled. Autogen can run in two main modes, Local or
        Product mode. Product mode is further subdivided into several sub-modes.<br/>
        <br/>
        <b>Local mode</b><br/>
        The purpose of this mode is:
        <ul>
          <li>Generation of ISI headers, HTML documentation, XML and TSA files</li>
          <li>Validation of input macro files</li>
        </ul>
        Autogen is normally run in a stand-alone fashion in this mode. This means that a lot of macro files
        will not default be included. The purpose is to validate and generate output for the specific macro file
        under test.<br/>
        <br/>
        <b>Product mode</b><br/>
        The purpose of this mode is:
        <ul>
          <li>Generation of a PMD file</li>
        </ul>
        In this mode autogen is normally run as part of a phone build. This means that a lot of macro files from
        the phone build is automatically included into the PMD file. This is to ensure that all traces possible from
        this phone build can be decoded in FastTrace using this PMD file.<br/>
        As mentioned above the product mode is actually
        subdivided into a number of minor product modes. The exact product mode determines what kind of macro files
        are automatically included into the PMD file.<br/>
        <br/>
        The following modes are supported:
        <table border="0">
          <tr>
            <td>AUTOGEN_ENVIRONMENT_LOCAL</td>            <td>Local mode for generation of various output files and
                                                              validation of the input macro file.</td>
          </tr><tr>
            <td>AUTOGEN_ENVIRONMENT_PRODUCT_MCU</td>      <td>Product mode for generation of a PMD file.<br/>
                                                              Autogen will include various macro files relevant for
                                                              the MCU world.</td>
          </tr><tr>
            <td>AUTOGEN_ENVIRONMENT_PRODUCT_DEVICE</td>   <td>Product mode for generation of a PMD file.<br/>
                                                              TBD</td>
          </tr><tr>
            <td>AUTOGEN_ENVIRONMENT_PRODUCT_SYMBIAN</td>  <td>Product mode for generation of a PMD file.<br/>
                                                              Autogen will include various macro files relevant for
                                                              Symbian and S60.</td>
          </tr><tr>
            <td>AUTOGEN_ENVIRONMENT_PRODUCT_DSP</td>      <td>Product mode for generation of a PMD file.<br/>
                                                              TBD</td>
          </tr><tr>
            <td>AUTOGEN_ENVIRONMENT_PRODUCT_ADSP</td>     <td>Product mode for generation of a PMD file.<br/>
                                                              TBD</td>
          </tr>
        </table>
      </summary>
    </section>
  </topic>
  <subtopic name="Main input and output files" topic="Autogen">
    <summary>
      This section will describe the input and output files from autogen.
    </summary>
    <section name="Macro Language">
      <summary>
        The macro language that autogen uses is actual standard C macros and must follow the same restrictions as 
        C macros. This also means that the input files are input into autogen by compiling autogen. When running 
        autogen the output files are generated (depending on the commandline options).<br/>
        <br/>
        The available macros that can be used to define trace statements and ISI messages are quite nummerous and
        can be grouped into a number of groups. These groups are listed in the table below including a small description
        of what types of macros that is covered by the group.
        <table border="0">
          <tr>
            <td><see cref_group="Property macros"/></td>
            <td>Property macros that can change various aspects of either macros or the complete macro file.<br/>
                Macros have a specific behaviour as defined in the description of the macro in the online reference 
                documentation. But the description of the macro also lists a number of valid properties that can affect 
                the macro if set. These properties can change default behaviour or augment default behaviour.<br/>
                See also <see cref_subtopic="How to use Properties?"/>.</td>
          </tr><tr>
            <td><see cref_group="Comment macros"/></td>
            <td>Comment macros allow to add comments to macro files.<br/>
                The comments will also be output in the generated output files which will not be the case with standard 
                C comments. Note that comments must be placed before the object which a given comment relates to.</td>
          </tr><tr>
            <td><see cref_group="Versioning macros"/></td>
            <td>Macros for specification of ISI version history.<br/>
            See also <see cref_subtopic="How does versioning work?"/>.</td>
          </tr><tr>
            <td><see cref_group="Feature flag macros"/></td>
            <td>Feature flag macros enables conditional parsing of groups of macros.<br/>
                These macros works similar to the #ifdef, #else and #endif pre-processor definitions in C.<br/>
                <see cref_subtopic="How to use feature flags?"/>.</td>
          </tr><tr>
            <td><see cref_group="Resource macros"/></td>
            <td>Macros for defining new resources.<br/>
                All ISI messages macro definitions and trace macro definitions must belong to a resource.<br/>
                See also <see cref_subtopic="How to use resources?"/>.</td>
          </tr><tr>
            <td><see cref_group="Message macros"/></td>
            <td>Macros for defining new ISI messages.<br/>
                These macros mark start and end of various types of ISI messages.<br/>
                See also <see cref_subtopic="How to make messages?"/>.</td>
          </tr><tr>
            <td><see cref_group="Sub block macros"/></td>
            <td>Various macros for defining subblocks.<br/>
            See also <see cref_subtopic="How to make subblocks?"/>.</td>
          </tr><tr>
            <td><see cref_group="Sequence macros"/></td>
            <td>Various macros for defining sequences.<br/>
                A sequence is basically a record of items that can be refered to in other macros.<br/>
                See also <see cref_subtopic="How to make arrays / sequences?"/>.</td>
          </tr><tr>
            <td><see cref_group="Item macros"/></td>
            <td>Item macros are macros for defining objects that is part of other objects.<br/>
                This group actually covers a lot of differient kinds of macros; from VALUE macros to
                TIMESTAMP macros. But they have one thing in common which is that they need to be contained
                in another object like a subblock, message, sequence etc.
                E.g. a subblock is a container object that can contain various item objects such as
                a 32 bit VALUE.</td>
          </tr><tr>
            <td><see cref_group="Constant macros"/></td>
            <td>Macros for defining various constants and tables of constants.<br/>
            See also <see cref_subtopic="How to use constants and constant tables?"/>.</td>
          </tr><tr>
            <td><see cref_group="Trace macros"/></td>
            <td>Various macros for defining traces.</td>
          </tr><tr>
            <td><see cref_group="FTD macros"/></td>
            <td>Macros to support Field Test Displays (FTD).</td>
          </tr><tr>
            <td><see cref_group="PPC macros"/></td>
            <td>Various macros to support PPC tables.</td>
          </tr>
        </table>
        <br/>
        The online autogen reference documentation contains a number of example macro files that can be used as 
        starting point for writing new macro files or as inspiration for writing specific macros.<br/>
        <ul>
          <li><see cref_example="Template file for ISI resources"/></li>
          <li><see cref_example="Template file for private ISI resources"/></li>
          <li><see cref_example="Template file for prefix ISI resources"/></li>
          <li><see cref_example="Template file for shared resources"/></li>
          <li><see cref_example="Template file for MCU traces"/></li>
          <li><see cref_example="Template file for invariant traces"/></li>
        </ul>
      </summary>
    </section>
    <section name="ISI headers">
      <summary>
        ISI header files are output when using the <see cref_subtopic="Autogen commandline"/> option <b>-oisihdr</b>.<br/>
        The ISI header files contains C structures that can help a developer accessing and storing data 
        in messages in the code. The following link (<a href="Examples/tut_xxx_isi.h" class="cref link">ISI header</a>) 
        points to the ISI header file generated from the <see cref_example="Template file for ISI resources"/>.<br/>
        <br/>
        Further documentation can be found here: <see cref_subtopic="ISI header files"/>.
      </summary>
    </section>
    <section name="HTML">
      <summary>
        The HTML pages are output when using the <see cref_subtopic="Autogen commandline"/> option <b>-ohtml</b>.<br/>
        The HTML pages are used for documenting the content of the macro files, e.g. documentation of the ISI
        message interface for a ISA server. Using this way of documenting ISI messages will ensure that the 
        documentation is always in-sync with the actual interface.<br/>
        The following link (<a href="Examples/tut_i_xxx_m.html" class="cref link">HTML page</a>) 
        points to the HTML documentation generated from the <see cref_example="Template file for ISI resources"/>.
        (Note that the real generated documentation are using frames and also contains a symbols page).<br/>
        <br/>
        Further documentation can be found here: <see cref_subtopic="ISI message descriptions (HTML)"/>.
      </summary>
    </section>
    <section name="XML">
      <summary>
        The XML files are output when using the <see cref_subtopic="Autogen commandline"/> option <b>-oxml</b>.<br/>
        The XML files corresponds to the input macro files and contains the same information (or close to).
        The intention is to have an easy format that can be used as input to other external programs, that 
        need to know the same information as present in the macro files. Examples of applications using the XML
        output:<br/>
        <ul>
          <li>RD Message API (Part of CoreTestTool)</li>
        </ul>
        <br/>
        The following link (<a href="Examples/tut_xxxx_isi.xml" class="cref link">XML file</a>) 
        points to the XML file generated from the <see cref_example="Template file for ISI resources"/>.<br/>
        <br/>
        Further documentation can be found here: <see cref_subtopic="XML Interface descriptions"/>.<br/>
        <br/>
        The generated XML output follows the following XML schema: 
        (<a href="Examples/autogen_xml.xsd" class="cref link">autogen_xml.xsd</a>)<br/>
        (Note that this schema here in the tutorial may become out-of-date compared to the one in the autogen distribution).
      </summary>
    </section>
    <section name="TSA">
      <summary>
        The TSA files are output when using the <see cref_subtopic="Autogen commandline"/> option <b>-otsa</b>.<br/>
        <br/>
        Further documentation can be found here: <see cref_subtopic="TSS Server API source files"/>.<br/>
        <br/>
      </summary>
    </section>
    <section name="PMD">
      <summary>
        The PMD files are output when using the <see cref_subtopic="Autogen commandline"/> options <b>-opmd</b>, 
        <b>-opmd_public</b> or <b>-opmd_restricted</b>.<br/>
        This file is used by FastTrace and contains the information about how to decode the binary trace statements sent
        from a phone being traced. A PMD file can be generated in three variants:
        <table border="0">
          <tr>
            <td>RD PMD file</td>            <td>This type of file is able to decode all traces. This is intended for
                                                internal use only.</td>
          </tr><tr>
            <td>Restricted PMD file</td>    <td>This type of file is restricted in capabilities in various ways.
                                                This type is intended for close and trusted 3rd parties to Nokia.</td>
          </tr><tr>
            <td>Public PMD file</td>        <td>This type of file is severily reduced in capabilities and is intended
                                                for distant 3rd parties to Nokia.</td>
          </tr>
        </table>
        <br/>
        Further documentation can be found here: <see cref_subtopic="PMD files"/>.
      </summary>
    </section>
  </subtopic>
  <subtopic name="Minor input files" topic="Autogen">
    <summary>
      This section will describe some of the minor input files that autogen makes use of.
    </summary>
    <section name="The .out file">
      <summary>
        Please see the <see cref_subtopic="Autogen commandline"/> option <b>-out</b>.
      </summary>
    </section>
    <section name="The disperin.cfg file">
      <summary>
        Please see the <see cref_subtopic="Autogen commandline"/> option <b>-disp</b>.
      </summary>
    </section>
    <section name="The pn_obj_auto.h file">
      <summary>
        Please see the <see cref_subtopic="Autogen commandline"/> option <b>-obj</b>.
      </summary>
    </section>
    <section name="The dsp5_identifiers.txt file">
      <summary>
        Please see the <see cref_subtopic="Autogen commandline"/> option <b>-dsp5</b>.
      </summary>
    </section>
  </subtopic>
  <subtopic name="Autogen commandline" topic="Autogen">
    <summary>
      Autogen supports a number of commandline arguments:<br/>
      <table border="0">
        <tr>
          <td>-?</td>                               <td>List all command line options relevant for the given mode 
                                                        autogen has been compiled in.</td>
        </tr><tr>
          <td>-obj(filename)</td>                   <td>Specify pn_obj_auto.h filepath<br/>
                                                        See also <see cref_subtopic="Minor input files"/>.</td>
        </tr><tr>
          <td>-out(filename)</td>                   <td>Specify .out filepath.<br/>
                                                        Autogen can read the .out files generated by the phone build and 
                                                        extract debugging information. 
                                                        Specifically it extracts all functions and their location in 
                                                        memory from the out file. It is possible to configure autogen to
                                                        also extract line number information. Autogen also supports extracting
                                                        debugging information from shared libraries (DLL libraries) using 
                                                        the same command line parameter.<br/>  
                                                        See <see cref_subtopic="Debug information (PMD)"/> for more information.<br/>
                                                        Used by FastTrace among other things to decode memory address to 
                                                        function names when decoding Mulder dumps.<br/>
                                                        See also <see cref_subtopic="Minor input files"/>.</td>
        </tr><tr>
          <td>-disp(filename)</td>                  <td>Specify disperin.cfg filepath.<br/>
                                                        See also <see cref_subtopic="Minor input files"/>.</td>
        </tr><tr>
          <td>-embed_pmd(filename)<br/>
              -embed_pmd_public(filename)<br/>
              -embed_pmd_restricted(filename)</td>  <td>Specify PMD (RD, public, restricted) file to embed.<br/>
                                                        Autogen supports to embed previously generated PMD files
                                                        into the PMD file currently being generated. This avoids
                                                        appending several PMD files in FastTrace.<br/>
                                                        See also <see cref_subtopic="Main input and output files"/>.</td>
        </tr><tr>
          <td>-dsp5(filename)</td>                  <td>Specify dsp5_identifiers.txt filepath.<br/>
                                                        See also <see cref_subtopic="Minor input files"/>.</td>
        </tr><tr>
          <td>-d(directory)</td>                    <td>Specify destination directory<br/>
                                                        All output goes into this directory until changed with a new
                                                        -d option. Example: -dxml -oxml -dhtml -ohtml. All xml output
                                                        will go into the directory named 'xml' and all html output will
                                                        go into the directory named 'html'.</td>
        </tr><tr>
          <td>-oisihdr</td>                         <td>Generate ISI header files.<br/>
                                                        Output directory determined by -d option.<br/>
                                                        See also <see cref_subtopic="Main input and output files"/>.</td>
        </tr><tr>
          <td>-ohtml</td>                           <td>Generate message specifications in HTML format.<br/>
                                                        Output directory determined by -d option.<br/>
                                                        See also <see cref_subtopic="Main input and output files"/>.</td>
        </tr><tr>
          <td>-otsa</td>                            <td>Generate TSS Server API source files.<br/>
                                                        Output directory determined by -d option.<br/>
                                                        See also <see cref_subtopic="Main input and output files"/>.</td>
        </tr><tr>
          <td>-oxml</td>                            <td>Generate XML files.<br/>
                                                        Output directory determined by -d option.<br/>
                                                        See also <see cref_subtopic="Main input and output files"/>.</td>
        </tr><tr>
          <td>-opmd<br/>
              -opmd_public<br/>
              -opmd_restricted<br/></td>            <td>Generate PMD (RD, public, restricted) file.<br/>
                                                        Output directory determined by -d option.<br/>
                                                        See also <see cref_subtopic="Main input and output files"/>.</td>
        </tr><tr>
          <td>-oxml_autobuilder_version</td>        <td>Undocumented</td>
        </tr><tr>
          <td>-pmd_debug</td>                       <td>Generate PMD debug log<br/>
                                                        Generates a number of .txt files containing debug information
                                                        about the contents of the generated PMD file. This is mostly 
                                                        useful for debugging the contents of a PMD file.<br/>
                                                        These file will be located together with the generated PMD file.
                                                    </td>
        </tr>
      </table>
    </summary>
  </subtopic>        
  <subtopic name="Autogen Makefiles" topic="Autogen">
    <summary>
      This section will describe the usage of the various Makefiles in the autogen directory.<br/>
      <br/>
      Please also have a look at the following links which describes how to generate various output using the 
      Makefiles:<br/>
      <br/>
      <see cref_subtopic="PMD files"/><br/>
      <see cref_subtopic="ISI message descriptions (HTML)"/><br/>
      <see cref_subtopic="ISI header files"/><br/>
      <see cref_subtopic="TSS Server API source files"/><br/>
      <see cref_subtopic="XML Interface descriptions"/><br/>
      <br/>
      Autogen supports the Makefiles shown below. Each Makefile compiles and executes autogen in a specific mode. 
      Please see <see cref_topic="Autogen"/>.
      <table border="0">
        <tr>
          <th>Makefile</th>           <th>Mode</th>
        </tr><tr>
          <td>MakeAutogen</td>        <td>AUTOGEN_ENVIRONMENT_PRODUCT_MCU</td>
        </tr><tr>
          <td>MakeAutogenDevice</td>  <td>AUTOGEN_ENVIRONMENT_PRODUCT_DEVICE</td>
        </tr><tr>
          <td>MakeAutogenLocal</td>   <td>AUTOGEN_ENVIRONMENT_LOCAL</td>
        </tr>
      </table>
      <br/>
      The last Makefile supported by autogen is: <b>MakeSig2MacroDSP5</b><br/>
      This is for making the sig2macro executable which is used in connection with DSP5. Please check 
      <see cref_topic="DSP5 traces"/> for further details.
    </summary>
  </subtopic>        
  <subtopic name="ti2grp" topic="Autogen">
    <summary>
      Describe how the ti2grp executable is intended to be used.
    </summary>
  </subtopic>        
  <subtopic name="Configuration of autogen" topic="Autogen">
    <summary>
      This section will give a detailed description of how to configure autogen.<br/>
      <br/>
      Please study the following link, <see cref_topic="autogen environments"/>, which describe configuration
      of autogen.
    </summary>
    <section name="autogen_conf.h">
      <summary>
        Will describe the purpose of autogen_conf.h
      </summary>
    </section>    
    <section name="autogen_server_conf.h">
      <summary>
        Will describe the purpose of autogen_server_conf.h
      </summary>
    </section>    
    <section name="autogen_ti_conf.h">
      <summary>
        Will describe the purpose of autogen_ti_conf.h
      </summary>
    </section>    
  </subtopic>        
  <topic name="Creating a macro file" group="Tutorial">
    <summary>
      The purpose of this section is to show how to construct a simple message macro file and simple trace macro file.
      And how to incorporate it into the code.<br/>
      <br/>
      See:
      <table border="0">
        <tr><td><see cref_subtopic="Tracing macro file"/></td></tr>
        <tr><td><see cref_subtopic="ISI message macro file"/></td></tr>
      </table>
      <!-- Suggestions: 
      Introduction to creating a macro file.<br/>
      Purpose: A walk through of how to make an macro file and how to compile it.
      <ul>
        <li>Two kinds of macro files: message - tracing</li>
        <li>Running stand alone - Local mode</li>
        <ul>
          <li>Validating macro file</li>
          <li>Windows / Unix</li>
        </ul>
        <li>In phone build - Product mode</li>
        <ul>
          <li>Unix</li>
          <ul>
            <li>Configuration files</li>
            <li>How to run make - how does the make tree work in S40 build</li>
          </ul>
        </ul>
      </ul>
      -->
    </summary>
  </topic>
  <subtopic name="Tracing macro file" topic="Creating a macro file">
    <summary>
      Please study the following sections in the online reference manual: <see cref_group="Traces"/> and subsections
      <see cref_subtopic="New MCU trace concept"/>, <see cref_subtopic="Adding traces to a component"/>.<br/>
      These contain descriptions of traces and how to make use of them in a program.
    </summary>
  </subtopic>        
  <subtopic name="ISI message macro file" topic="Creating a macro file">
    <summary>
      This section will contain a description of how to create and use a ISI message macro file.
    </summary>
  </subtopic>
  <topic name="Using 64-bit macros" group="Tutorial">
    <summary>
      64-bit macros are enabled when PMD_FILE_FORMAT 600 is used <b>and</b> PROPERTY_ALIGNMENT_64_BITS has been applied to resource.<br/>
      PMD_FILE_FORMAT 600 is activated from autogen_conf.h / autogen_local_conf.h by adding this define:<br/>
      <b>#define PMD_FILE_FORMAT  600</b><br/>
      or replace existing #define PMD_FILE_FORMAT <b>nnn</b> with <b>600</b>.<br/>
      <br/>
      For backwards compatibility reasons autogen will assume that 32-bit alignment is to be used even when running PMD_FILE_FORMAT 600.<br/><br/>
      <b>IMPORTANT: Obsolete macros such as ITEM_LIMITS must be updated before using PMD_FILE_FORMAT 600</b><br/><br/>
      To inform autogen that 64-bit macros are used and that 64-bit alignment is to be checked the resource property <see cref_property="PROPERTY_ALIGNMENT_64_BITS"/> must be applied.<br/>
      <br/>
      <code filename="property_64_bit_alignment.txt"/>
      <br/>
      The following macros support 64-bits fields:<br/><br/>
      <see cref_macro="BIT_TBL_BEGIN"/><br/>
      <see cref_macro="CONST_TBL_BEGIN"/><br/>
      <see cref_macro="CONSTANT"/><br/>
      <see cref_macro="FILLER"/><br/>
      <see cref_macro="MERGE_BEGIN"/><br/>
      <see cref_macro="POINTER"/><br/>
      <see cref_macro="VALUE"/><br/>
      <see cref_macro="VALUE_EX"/><br/>
      <br/>
      Furthermore, DDWORD predefined sequences are available, see <see cref_topic="Sequences"/><br/>
      <br/>
      In case you need to support 64-bit fields in an existing message macro file please see <see cref_subtopic="Updating an existing message macro file"/><br/>
      <br/>
      If your message macro file is including a shared file and the shared file starts using 64-bit macros then you need to update your file. See <see cref_subtopic="Shared files"/><br/>
    </summary>
  </topic>
  <subtopic name="Updating an existing message macro file" topic="Using 64-bit macros">
    <summary>
      When a server interface starts using 64-bits fields the message macro file must be updated:<br/>
      PMD file format 6.00 must be used in both Local mode and Product mode. <b>The entire phone build must switch to PMD file format 6.00 the very moment one server requires it!</b><br/>
      Resource property <see cref_property="PROPERTY_ALIGNMENT_64_BITS"/> must be applied to the resource.<br/>
      Existing alignment (32-bits) must be updated to 64-bits.<br/><br/>
      Scenario for the following example is that a subblock carrying a 64-bit value was needed. New versions of subblocks and message was created in order to meet 64-bits alignment requirement.
      Property <see cref_property="PROPERTY_ALIGNMENT_64_BITS"/> has been applied to resource:<br/>
      <code filename="update_to_64_bits_macro.txt"/><br/>
    </summary>
  </subtopic>
  <subtopic name="Alignment" topic="Using 64-bit macros">
    <summary>
      Standard alignment rules for 8, 16, and 32 bits fields still apply when using 64-bits fields so basically most existing declarations in sequences, subblocks, and messages are not affected.<br/>
      However, variable fillers (e.g. after variable sized arrays) need adjustment to 64-bits alignment.<br/>
      In the following example proper alignment to 64-bit has been implemented and PMD file format 6.00 is used:<br/>
      <code filename="missing_64_bit_alignment_prop_macro.txt"/><br/>
      Error generated by autogen: <br/>
      <b>Error: Argument 'length' is out of range. For table length > 32 please apply resource property 'PROPERTY_ALIGNMENT_64_BITS'</b><br/><br/>
      The property informing autogen that 64-bits alignment is to be used has not been applied. See <see cref_topic="Using 64-bit macros"/><br/>
      <br/>
      In case PMD file format 5.0x is specified in autogen_local_conf.h / autogen_conf.h the following error will be generated:<br/>
      <b>Error: Argument 'length' is out of range. Value must be between 1 and 32</b><br/>
    </summary>
  </subtopic>
  <subtopic name="Shared files" topic="Using 64-bit macros">
    <summary>
      This section describes what to do when a shared resource starts using 64-bits macros, in particular the impact on clients.<br/>
      Example of shared file using 64-bit values:<br/>
      <code filename="shared_file_64_bits_macro.txt"/><br/>
      Owner of shared file: <br/>
      <code filename="owner_64_bit_shared_macro.txt"/><br/>
      Example of client before update: <br/>
      <code filename="client_64_bit_shared_not_updated_macro.txt"/><br/>
      Error generated by autogen: <br/>
      <b>Error: Mixed 32-bit and 64-bit macros. Shared file 'PN_TEST' has property 'PROPERTY_ALIGNMENT_64_BITS'</b><br/><br/>
      Client after update: <br/>
      <code filename="client_64_bit_shared_updated_macro.txt"/><br/>
    </summary>
  </subtopic>
  <topic name="Macro language" group="Tutorial">
    <summary>
      The subtopics in this section describes various aspects of the macro language. The subtopics may not cover
      the full macro language. In that case please refer to autogens online reference manual.<br/>
      <br/>
      Subtopics:
      <table>
        <tr><td><see cref_subtopic="How to use resources?"/></td></tr>
        <tr><td><see cref_subtopic="How to make messages?"/></td></tr>
        <tr><td><see cref_subtopic="How does versioning work?"/></td></tr>
        <tr><td><see cref_subtopic="How to use Properties?"/></td></tr>
        <tr><td><see cref_subtopic="How to use feature flags?"/></td></tr>
        <tr><td><see cref_subtopic="How to make subblocks?"/></td></tr>
        <tr><td><see cref_subtopic="How to make arrays / sequences?"/></td></tr>
        <tr><td><see cref_subtopic="How to make strings?"/></td></tr>
        <tr><td><see cref_subtopic="How does Fillers and alignments work?"/></td></tr>
        <tr><td><see cref_subtopic="How to use choices?"/></td></tr>
        <tr><td><see cref_subtopic="How to use constants and constant tables?"/></td></tr>
      </table>
    </summary>
  </topic>
  <subtopic name="How to use resources?" topic="Macro language">
   <summary>
     This section will describe resources in more detail.<br/>
     <br/>
     The following link gives an overview of the available resources in autogen: <see cref_group="Resources"/>.
   </summary>
  </subtopic>        
  <subtopic name="How to make messages?" topic="Macro language">
    <summary>
      This section will contain a description of the various macros related to constructing various types
      of ISI messages. Various topics:
      <ul>
        <li>Standard message</li>
        <li>Sub-messages</li>
        <li>Message pairs</li>
      </ul>
    </summary>
  </subtopic>        
  <subtopic name="How does versioning work?" topic="Macro language">
   <summary>
     Please study the contents of the following link: <see cref_topic="Versioning"/>.<br/>
     <br/>
     The following links also contain descriptions of a number of errors one can come across in connection with 
     versioning of macros: 
     <ul>
       <li><see cref_errorcode="Error_4"/></li>
       <li><see cref_errorcode="Error_5"/></li>
       <li><see cref_errorcode="Error_6"/></li>
       <li><see cref_errorcode="Error_10"/></li>
     </ul>
   </summary>
  </subtopic>        
  <subtopic name="How to use Properties?" topic="Macro language">
    <summary>
      Macros have a specific behaviour as defined in the description of the macro. But each macro 
      also lists a number of valid properties that can affect the macro if set. These properties can
      change default behaviour or augment default behaviour of the given macro.<br/>
      <br/>
      Please study the following link for further details: <see cref_topic="Properties"/><br/>
    </summary>
    <section name="Properties overview">
      <summary>
        The various types of properties can be divided into a number of main groups. These groups are listed
        below with a short description of what kind of properties they contain.
        <table border="0">
          <tr>
            <td><see cref_group="Versioning properties"/></td>
            <td>This group contains various properties related to ISI versioning of macro files. A macro file can 
                consist of several versions (Check <see cref_subtopic="How does versioning work?"/>) and these 
                properties can be used to describe various properties of each ISI version of the macro file
                like 'change date', 'change person', 'change reason' etc. Most of the properties are tied to the
                macro <see cref_macro="ISI_VERSION_HISTORY"/>.</td>
          </tr><tr>
            <td><see cref_group="Resource properties"/></td>
            <td>This group of properties are global in scope and therefor ties to the resource 
                (Check <see cref_subtopic="How to use resources?"/>) defined in the macro file or more preciesly the 
                macro <see cref_macro="RES_BEGIN"/>.</td>
          </tr><tr>
            <td><see cref_group="Message properties"/></td>
            <td>Various properties that relates to ISI message definitions.</td>
          </tr><tr>
            <td><see cref_group="Sub block properties"/></td>
            <td>Various properties that relates to definition of subblocks. See also <see cref_macro="SB_BEGIN"/></td>
          </tr><tr>
            <td><see cref_group="Item properties"/></td>
            <td>These properties relates to item macros. <see cref_group="Item macros"/> are macros that are part
                of a container like a message (<see cref_group="Message macros"/>), subblock (<see cref_group="Sub block macros"/>), 
                sequence (<see cref_group="Sequence macros"/>) etc.</td>
          </tr><tr>
            <td><see cref_group="Trace properties"/></td>
            <td>This group contains various properties that relates to tracing.</td>
          </tr><tr>
            <td><see cref_group="FTD properties"/></td>
            <td>These properties relates to Field Test Display (FTD) definitions. Please see the description of 
                <see cref_group="FTD data"/> and the various <see cref_group="FTD macros"/>.</td>
          </tr><tr>
            <td><see cref_group="HTML properties"/></td>
            <td>This group of properties controls various aspects around the generation of HTML documentation.<br/>
            See also <see cref_subtopic="Main input and output files"/>.</td>
          </tr><tr>
            <td><see cref_group="ISI header properties"/></td>
            <td>This group of properties controls various aspects around the generation of ISI header files.<br/>
            See also <see cref_subtopic="Main input and output files"/>.</td>
          </tr><tr>
            <td><see cref_group="PMD properties"/></td>
            <td>This group of properties controls various aspects around the generation of PMD files.<br/>
            See also <see cref_subtopic="Main input and output files"/>.</td>
          </tr><tr>
            <td><see cref_group="General properties"/></td>
            <td>This group lists various general properties.</td>
          </tr>
        </table>
      </summary>
    </section>
  </subtopic>        
  <subtopic name="How to use feature flags?" topic="Macro language">
    <summary>
     Please study the contents of the following link: <see cref_topic="Feature flags"/>.
    </summary>  
  </subtopic>        
  <subtopic name="How to make subblocks?" topic="Macro language">
    <summary>
      Please study the contents of the following link: <see cref_topic="Sub blocks"/>.
    </summary>
  </subtopic>        
  <subtopic name="How to make arrays / sequences?" topic="Macro language">
    <summary>
      Please study the contents of the following links: <see cref_topic="Arrays"/> and <see cref_topic="Sequences"/>.
    </summary>
  </subtopic>        
  <subtopic name="How to make strings?" topic="Macro language">
    <summary>
      Please study the contents of the following link: <see cref_topic="Strings"/>.
    </summary>  
  </subtopic>        
  <subtopic name="How does Fillers and alignments work?" topic="Macro language">
    <summary>
      Please study the following description: <see cref_errorcode="Error_7"/>
    </summary>  
  </subtopic>        
  <subtopic name="How to use choices?" topic="Macro language">
    <summary>
      Will contain a description of how to make choises in the macro language.<br/>
      <br/>
      For now please check the macro descriptions:<br/>
      <see cref_macro="CHOICE_BEGIN"/><br/>
      <see cref_macro="CHOICE_VALUE_BEGIN"/><br/>
      <see cref_macro="CHOICE_END"/><br/>
      <see cref_macro="CHOICE_FORWARD_BEGIN"/><br/>
      <see cref_macro="CASE_BEGIN"/><br/>
      <see cref_macro="CASE_END"/><br/>
      <see cref_macro="DEFAULT_BEGIN"/><br/>
      <see cref_macro="DEFAULT_END"/><br/>
    </summary>  
  </subtopic>        
  <subtopic name="How to use constants and constant tables?" topic="Macro language">
    <summary>
      This section will contain a description of constants and constant tables like:
      <ul>
        <li>Standard constant tables</li>
        <li>Constant bit tables</li>
        <li>Derrive constant and bit tables</li>
      </ul>
    </summary>
    <section name="Constants">
      <summary>
        A constant can be defined in a macro file as
        <pre> 
            #define MYCONST 0x01
        </pre>
        But this will not make it known to autogen. Autogen will just see the value 0x01.
        To make a constant (single constant) known to autogen one of the two macros can be used.
        <ul>
          <li><see cref_macro="CONSTANT"/></li>
          <li><see cref_macro="CONSTANT_VER"/></li>
        </ul>
        The <b>CONSTANT_VER</b> is for versioning of a constant.<br/>
        <br/>
        When defined using one of the above macros the constant will be known to autogen and will appear in the 
        ISI header files and HTML documentation with its name and value.<br/>
        <br/>
        An example would be:
        <pre>
          CONSTANT(MYCONST, 0x04)
        </pre>
        This make the constant present in the HTML documentation and in the ISI header files as
        <pre>
          #define MYCONST                                  0x04
        </pre>
        A slightly different way to define the CONSTANT is
        <pre>
          #define MYCONST 0x04

          CONSTANT(MYCONST, MYCONST) 
        </pre>
        This way MYCONST (as the value 0x04) can be used in subsequent macros like:
        <pre>
          PROPERTY_VALUE(PROPERTY_ITEM_MAXIMUM_VALUE, MYCONST)
          ...
        </pre>
      </summary>
    </section>
    <section name="Constant tables">
      <summary>
        TBD
        <!--
        A constant table is set of constant values. They can be useful where a field in a message can take a specific
        set of values. An example would be in CHOICE where the value that determines the specific case would come from
        a limited set of constant values. See also <see cref_subtopic="How to use choices?"/>.<br/>
        <br/>
        An example of a constant table:
        -->
      </summary>
    </section>
    <section name="Bit tables">
      <summary>
        TBD
      </summary>
    </section>
    <section name="Derived tables">
      <summary>
        TBD
      </summary>
    </section>
  </subtopic>        
  <topic name="Frequently Asked Questions" group="Tutorial">
    <summary>
      This section tries to answer a number of frequently asked questions. The questions have been 
      divided into a number of sub-categories:
      <table>
        <tr><td><see cref_subtopic="Configuration"/></td></tr>
        <tr><td><see cref_subtopic="Message Macro Syntax"/></td></tr>
        <tr><td><see cref_subtopic="ISI Headers"/></td></tr>
        <tr><td><see cref_subtopic="HTML"/></td></tr>
        <tr><td><see cref_subtopic="XML"/></td></tr>
        <tr><td><see cref_subtopic="TSS Server API"/></td></tr>
      </table>
    </summary>
  <subtopic name="Configuration" topic="Frequently Asked Questions">
    <summary>
      This section contains frequently asked questions related on how to configure autogen.
    </summary>
    <section name="Empty">
      <summary>
      </summary>
    </section>
  </subtopic>        
  <subtopic name="Message Macro Syntax" topic="Frequently Asked Questions">
    <summary>
      This section contains frequently asked questions related to message macro syntax.
    </summary>
    <section name="Empty">
      <summary>
      </summary>
    </section>
  </subtopic>        
  <subtopic name="ISI Headers" topic="Frequently Asked Questions">
    <summary>
      This section contains frequently asked questions related to generation of ISI header files.
    </summary>
    <section name="Empty">
      <summary>
      </summary>
    </section>
  </subtopic>        
  <subtopic name="HTML" topic="Frequently Asked Questions">
    <summary>
      This section contains frequently asked questions related to generation of HTML documentation.
    </summary>
    <section name="Empty">
      <summary>
      </summary>
    </section>
  </subtopic>        
  <subtopic name="XML" topic="Frequently Asked Questions">
    <summary>
      This section contains frequently asked questions related to generation of XML.
    </summary>
    <section name="Empty">
      <summary>
      </summary>
    </section>
  </subtopic>        
  <subtopic name="TSS Server API" topic="Frequently Asked Questions">
    <summary>
      This section contains frequently asked questions related to generation of TSA output.
    </summary>
    <section name="Empty">
      <summary>
      </summary>
    </section>
  </subtopic>        
  </topic>
</autogen>